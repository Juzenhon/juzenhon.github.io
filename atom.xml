<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>黑色红桃7</title>
    <link href="http://example.com" />
    <updated>2021-04-04T14:10:51.959Z</updated>
    <category term="test_tag" />
    <entry>
        <id>http://example.com/hello-world/</id>
        <title>Hello World</title>
        <link rel="alternate" href="http://example.com/hello-world/"/>
        <content type="html">&lt;p&gt;Welcome to &lt;a href=&#34;https://hexo.io/&#34;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&#34;https://hexo.io/docs/&#34;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&#34;https://hexo.io/docs/troubleshooting.html&#34;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&#34;https://github.com/hexojs/hexo/issues&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;Quick-Start&#34;&gt;&lt;a href=&#34;#Quick-Start&#34; class=&#34;headerlink&#34; title=&#34;Quick Start&#34;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&#34;Create-a-new-post&#34;&gt;&lt;a href=&#34;#Create-a-new-post&#34; class=&#34;headerlink&#34; title=&#34;Create a new post&#34;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ hexo new &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/writing.html&#34;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;Run-server&#34;&gt;&lt;a href=&#34;#Run-server&#34; class=&#34;headerlink&#34; title=&#34;Run server&#34;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ hexo server&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/server.html&#34;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;Generate-static-files&#34;&gt;&lt;a href=&#34;#Generate-static-files&#34; class=&#34;headerlink&#34; title=&#34;Generate static files&#34;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ hexo generate&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/generating.html&#34;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;Deploy-to-remote-sites&#34;&gt;&lt;a href=&#34;#Deploy-to-remote-sites&#34; class=&#34;headerlink&#34; title=&#34;Deploy to remote sites&#34;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ hexo deploy&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/one-command-deployment.html&#34;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="test_tag" />
        <updated>2021-04-04T14:10:51.959Z</updated>
    </entry>
    <entry>
        <id>http://example.com/First/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/First/"/>
        <content type="html">&lt;p&gt;— title: First Night — &amp;gt; 我有一头&lt;strong&gt;小毛驴&lt;/strong&gt;，可是我从来都不骑。&lt;/p&gt;
</content>
        <updated>2021-04-03T14:15:19.494Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2018-11-20-rust-static/</id>
        <title>rust static详解</title>
        <link rel="alternate" href="http://example.com/2018-11-20-rust-static/"/>
        <content type="html">&lt;h3 id=&#34;static-语法&#34;&gt;&lt;a href=&#34;#static-语法&#34; class=&#34;headerlink&#34; title=&#34;static 语法&#34;&gt;&lt;/a&gt;static 语法&lt;/h3&gt;&lt;figure class=&#34;highlight ada&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs ada&#34;&gt;static mut? IDENTIFER: &lt;span class=&#34;hljs-keyword&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;hljs-type&#34;&gt;(= &lt;/span&gt;Expresssion)?;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中mut可有可无，Expresssion为表达式，可以没有。&lt;/p&gt;
&lt;h3 id=&#34;static与常量有区别&#34;&gt;&lt;a href=&#34;#static与常量有区别&#34; class=&#34;headerlink&#34; title=&#34;static与常量有区别&#34;&gt;&lt;/a&gt;static与常量有区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;static有自己的内存地址，其生命周期是‘static的，常量没有&lt;/li&gt;
&lt;li&gt;所有的对static item的引用指向同一个地址，而每个常量都有自己的地址&lt;/li&gt;
&lt;li&gt;static的类型必须是Sync的，跨线程访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mut-static&#34;&gt;&lt;a href=&#34;#mut-static&#34; class=&#34;headerlink&#34; title=&#34;mut static&#34;&gt;&lt;/a&gt;mut static&lt;/h3&gt;&lt;p&gt;如果一个static item是mut的，并发访问时可能会有问题，所以对他的引用是unsafe的。我们要自己确保他的正确性。&lt;/p&gt;
&lt;h3 id=&#34;static-变量&#34;&gt;&lt;a href=&#34;#static-变量&#34; class=&#34;headerlink&#34; title=&#34;static 变量&#34;&gt;&lt;/a&gt;static 变量&lt;/h3&gt;&lt;p&gt;按照static的语法定义变量时经常遇到这样的错误:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;calls in statics are limited to constant functions, tuple structs and tuple variants&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说上面的Expresssion只是条件的。只能是常量函数，tuple结构等。而不能像Java语言一样 static Object STATIC_OBJ = new Object();&lt;/p&gt;
&lt;p&gt;其中主要的区别在于是static的初始化必须是在编译期可确定的。也就是说其内存大小是在编译期确定的，而Java是在运行时。&lt;/p&gt;
&lt;h3 id=&#34;lazy-static&#34;&gt;&lt;a href=&#34;#lazy-static&#34; class=&#34;headerlink&#34; title=&#34;lazy_static&#34;&gt;&lt;/a&gt;lazy_static&lt;/h3&gt;&lt;p&gt;由于rust static在编译期确定大小的特性，一些rust程序员在编写代码时产生了诸多不便，就有了&lt;a href=&#34;https://github.com/rust-lang-nursery/lazy-static.rs&#34;&gt;lazy_static&lt;/a&gt;这个库。&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;lazy_static! &amp;#123;&lt;br&gt;    &lt;span class=&#34;hljs-keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;ref&lt;/span&gt; HASHMAP: HashMap&amp;lt;&lt;span class=&#34;hljs-built_in&#34;&gt;u32&lt;/span&gt;, &amp;amp;&lt;span class=&#34;hljs-symbol&#34;&gt;&amp;#x27;static&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;str&lt;/span&gt;&amp;gt; = &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; m = HashMap::new();&lt;br&gt;        m.insert(&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;);&lt;br&gt;        m.insert(&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;);&lt;br&gt;        m.insert(&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;);&lt;br&gt;        m&lt;br&gt;    &amp;#125;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;lazy_static是第一次使用时调用初始化，相当于把初始化挪到了运行时。&lt;/p&gt;
&lt;h3 id=&#34;lazy-mut&#34;&gt;&lt;a href=&#34;#lazy-mut&#34; class=&#34;headerlink&#34; title=&#34;lazy_mut&#34;&gt;&lt;/a&gt;lazy_mut&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://docs.rs/lazy_mut/0.1.0/lazy_mut/&#34;&gt;lazy_mut&lt;/a&gt;是用来解决变量延迟初始化的, 也包括static mut。&lt;/p&gt;
</content>
        <updated>2018-11-20T12:46:11.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2018-11-02-cell/</id>
        <title>rust cell 详解</title>
        <link rel="alternate" href="http://example.com/2018-11-02-cell/"/>
        <content type="html">&lt;h2 id=&#34;背景介绍&#34;&gt;&lt;a href=&#34;#背景介绍&#34; class=&#34;headerlink&#34; title=&#34;背景介绍&#34;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/cell/index.html&#34;&gt;https://doc.rust-lang.org/std/cell/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;众所周知，rust的内存安全是基于一个规则，一个对像须满足以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只存在一个可变引用&lt;/li&gt;
&lt;li&gt;有多个不可变引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在写rust代码时，会发现这样的规则在写代码时会受到一定的束缚。于是rust官方出了一个可以灵活解决对像可变性问题的工具cell。&lt;/p&gt;
&lt;h2 id=&#34;cell与Mutex等的不同&#34;&gt;&lt;a href=&#34;#cell与Mutex等的不同&#34; class=&#34;headerlink&#34; title=&#34;cell与Mutex等的不同&#34;&gt;&lt;/a&gt;cell与Mutex等的不同&lt;/h2&gt;&lt;p&gt;诚然我们可以用Mutex, atomic等来解决可变性问题，但cell与mutex有本质的不同。&lt;br&gt;cell是线程安全的（没有实现Sync，不能跨线程访问），Mutex主要用来解决多线程数据竞争的。&lt;/p&gt;
&lt;h2 id=&#34;cell的具体分析&#34;&gt;&lt;a href=&#34;#cell的具体分析&#34; class=&#34;headerlink&#34; title=&#34;cell的具体分析&#34;&gt;&lt;/a&gt;cell的具体分析&lt;/h2&gt;&lt;p&gt;cell的实现分Cell, RefCell, UnsafeCell，还有一个开源实现LazyCell&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#[repr(transparent)]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;Cell&lt;/span&gt;&lt;/span&gt;&amp;lt;T: ?&lt;span class=&#34;hljs-built_in&#34;&gt;Sized&lt;/span&gt;&amp;gt; &amp;#123;&lt;br&gt;    value: UnsafeCell&amp;lt;T&amp;gt;,&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;RefCell&lt;/span&gt;&lt;/span&gt;&amp;lt;T: ?&lt;span class=&#34;hljs-built_in&#34;&gt;Sized&lt;/span&gt;&amp;gt; &amp;#123;&lt;br&gt;    borrow: Cell&amp;lt;BorrowFlag&amp;gt;,&lt;br&gt;    value: UnsafeCell&amp;lt;T&amp;gt;,&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#[repr(transparent)]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;UnsafeCell&lt;/span&gt;&lt;/span&gt;&amp;lt;T: ?&lt;span class=&#34;hljs-built_in&#34;&gt;Sized&lt;/span&gt;&amp;gt; &amp;#123;&lt;br&gt;    value: T,&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;p&gt;从源码上来看Cell和RefCell的内部都是由UnsafeCell来实现的, 要想理解Cell与RefCell就需要先了解UnsafeCell&lt;/p&gt;
&lt;h3 id=&#34;UnsafeCell&#34;&gt;&lt;a href=&#34;#UnsafeCell&#34; class=&#34;headerlink&#34; title=&#34;UnsafeCell&#34;&gt;&lt;/a&gt;UnsafeCell&lt;/h3&gt;&lt;p&gt;UnsafeCell非常简单，有一个重要的方法：&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//返回一个可变指针&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;get&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;) -&amp;gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; T &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;as&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; UnsafeCell&amp;lt;T&amp;gt; &lt;span class=&#34;hljs-keyword&#34;&gt;as&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; T &lt;span class=&#34;hljs-keyword&#34;&gt;as&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; T&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;p&gt;通过一个不可变对像返回一个可变的对像指针，Cell与RefCell正是利用了这个达到相应的目的，前提是他们是线程安全的。&lt;/p&gt;
&lt;h3 id=&#34;Cell&#34;&gt;&lt;a href=&#34;#Cell&#34; class=&#34;headerlink&#34; title=&#34;Cell&#34;&gt;&lt;/a&gt;Cell&lt;/h3&gt;&lt;p&gt;看一下replace,get, set, take等方法，都是基于UnsafeCell返回的可变指针的内存操作&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;replace&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;, val: T) -&amp;gt; T &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-comment&#34;&gt;// SAFETY: This can cause data races if called from a separate thread,&lt;/span&gt;&lt;br&gt;        &lt;span class=&#34;hljs-comment&#34;&gt;// but `Cell` is `!Sync` so this won&amp;#x27;t happen.&lt;/span&gt;&lt;br&gt;        mem::replace(&lt;span class=&#34;hljs-keyword&#34;&gt;unsafe&lt;/span&gt; &amp;#123; &amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;.value.get() &amp;#125;, val)&lt;br&gt;    &amp;#125;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//T: Copy    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;get&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;) -&amp;gt; T &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-comment&#34;&gt;// SAFETY: This can cause data races if called from a separate thread,&lt;/span&gt;&lt;br&gt;        &lt;span class=&#34;hljs-comment&#34;&gt;// but `Cell` is `!Sync` so this won&amp;#x27;t happen.&lt;/span&gt;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;unsafe&lt;/span&gt; &amp;#123; *&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;.value.get() &amp;#125;&lt;br&gt;    &amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;h3 id=&#34;RefCell&#34;&gt;&lt;a href=&#34;#RefCell&#34; class=&#34;headerlink&#34; title=&#34;RefCell&#34;&gt;&lt;/a&gt;RefCell&lt;/h3&gt;&lt;p&gt;Refcell是在Cell的增强版，他在Cell的基础上添加了借用，内部维护着一个借用的标识，在运行时做借用检查。&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;borrow&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;) -&amp;gt; Ref&amp;lt;&lt;span class=&#34;hljs-symbol&#34;&gt;&amp;#x27;_&lt;/span&gt;, T&amp;gt; &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;.try_borrow().expect(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;already mutably borrowed&amp;quot;&lt;/span&gt;)&lt;br&gt;    &amp;#125;&lt;br&gt;    &lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;borrow_mut&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;) -&amp;gt; RefMut&amp;lt;&lt;span class=&#34;hljs-symbol&#34;&gt;&amp;#x27;_&lt;/span&gt;, T&amp;gt; &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;.try_borrow_mut().expect(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;already borrowed&amp;quot;&lt;/span&gt;)&lt;br&gt;    &amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;p&gt;主要方法borrow和borrow_mut返回相应的引用对像，当Ref或RefMut销毁时相应的借用关系消除&lt;/p&gt;
&lt;h3 id=&#34;LazyCell&#34;&gt;&lt;a href=&#34;#LazyCell&#34; class=&#34;headerlink&#34; title=&#34;LazyCell&#34;&gt;&lt;/a&gt;LazyCell&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/indiv0/lazycell&#34;&gt;https://github.com/indiv0/lazycell&lt;/a&gt;, 从代码看其和Cell功能类似，用于延迟初始化。&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;LazyCell&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt; &amp;#123;&lt;br&gt;    inner: UnsafeCell&amp;lt;&lt;span class=&#34;hljs-built_in&#34;&gt;Option&lt;/span&gt;&amp;lt;T&amp;gt;&amp;gt;,&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;





</content>
        <updated>2018-11-02T14:39:42.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2018-2-11-daemon-thread/</id>
        <title>java守护线程</title>
        <link rel="alternate" href="http://example.com/2018-2-11-daemon-thread/"/>
        <content type="html">&lt;h3 id=&#34;守护线程&#34;&gt;&lt;a href=&#34;#守护线程&#34; class=&#34;headerlink&#34; title=&#34;守护线程&#34;&gt;&lt;/a&gt;守护线程&lt;/h3&gt;&lt;p&gt;线程分为前台线程（用户线程）与后台线程（守护线程），守护线程并不常用，他主要为其他对像或用户线程提供服务。一般的守护线程如   jvm垃圾回收线程，和内存管理线程等。&lt;br&gt;守护线程具有最低的优先级，他不依赖于终端，但依赖于虚拟机。 而jvm的退出是以用户线程的运行结束为终止的。&lt;/p&gt;
&lt;h3 id=&#34;使用方法&#34;&gt;&lt;a href=&#34;#使用方法&#34; class=&#34;headerlink&#34; title=&#34;使用方法&#34;&gt;&lt;/a&gt;使用方法&lt;/h3&gt;&lt;figure class=&#34;highlight lasso&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs lasso&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;Thread&lt;/span&gt; th = &lt;span class=&#34;hljs-literal&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;Thread&lt;/span&gt;();&lt;br&gt;th.setDaemon(&lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;); &lt;span class=&#34;hljs-comment&#34;&gt;//设置为守护线程&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;setDaemon方法必须要在start方法之前调，否则会产生illegalThreadStateException;&lt;/p&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;&lt;a href=&#34;#注意事项&#34; class=&#34;headerlink&#34; title=&#34;注意事项&#34;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;p&gt;对于jre来说程序的运行结束的标志是所有前台线程的运行结束，而不管守护线程是否运行完。&lt;/p&gt;
&lt;p&gt;当前台线程运行完成时，程序就自动终止了，因此不要在守护线程中做文件，输入输出等操作。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs java&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;    Thread daemon_th =  &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; Thread(&lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-meta&#34;&gt;@Override&lt;/span&gt;&lt;br&gt;        &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;            System.out.println(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;daemon thread start&amp;quot;&lt;/span&gt;);&lt;br&gt;            &lt;span class=&#34;hljs-keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;br&gt;                Thread.sleep(&lt;span class=&#34;hljs-number&#34;&gt;1000&lt;/span&gt;);&lt;br&gt;            &amp;#125; &lt;span class=&#34;hljs-keyword&#34;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;br&gt;                e.printStackTrace();&lt;br&gt;            &amp;#125;&lt;br&gt;            System.out.println(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;daemon thread finished&amp;quot;&lt;/span&gt;);&lt;br&gt;        &amp;#125;&lt;br&gt;    &amp;#125;);&lt;br&gt;    daemon_th.setDaemon(&lt;span class=&#34;hljs-keyword&#34;&gt;true&lt;/span&gt;);&lt;br&gt;    Thread work_th =  &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; Thread(&lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-meta&#34;&gt;@Override&lt;/span&gt;&lt;br&gt;        &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;            System.out.println(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;work thread finished&amp;quot;&lt;/span&gt;);&lt;br&gt;        &amp;#125;&lt;br&gt;    &amp;#125;);&lt;br&gt;    daemon_th.start();&lt;br&gt;    work_th.start();&lt;br&gt;    System.out.println(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;main thread finished&amp;quot;&lt;/span&gt;);&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;运行结果为:&lt;br&gt;daemon thread start&lt;br&gt;work thread finished&lt;br&gt;main thread finished&lt;/p&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;&lt;a href=&#34;#应用场景&#34; class=&#34;headerlink&#34; title=&#34;应用场景&#34;&gt;&lt;/a&gt;应用场景&lt;/h3&gt;&lt;p&gt;由于以上的特点，守护线程不适合做资源申请回收相关的操作。适合做为其他线程服务的工作。&lt;/p&gt;
&lt;p&gt;如java的垃圾回收线程就是典型的守护线程。&lt;/p&gt;
</content>
        <updated>2018-02-11T05:06:28.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2013-12-24-android-touch/</id>
        <title>android touch处理流程</title>
        <link rel="alternate" href="http://example.com/2013-12-24-android-touch/"/>
        <content type="html">&lt;h3 id=&#34;Touch-事件简介&#34;&gt;&lt;a href=&#34;#Touch-事件简介&#34; class=&#34;headerlink&#34; title=&#34;Touch 事件简介&#34;&gt;&lt;/a&gt;Touch 事件简介&lt;/h3&gt;&lt;p&gt;在android进行ui交互时，不可避免的要涉及到touch事件，如onClick，onLongClick ,onItemClick等等事件都是经过一连串的touch形成的。&lt;/p&gt;
&lt;p&gt;MotionEvent分为以下几个动作：&lt;br&gt;MotionEvent.ACTION_DOWN——–第一个手指按下的动作&lt;br&gt;MotionEvent.ACTION_MOVE ——–按下后的移动操作&lt;br&gt;MotionEvent.ACTION_POINTER_DOWN ——-第二根及以上的手指按下&lt;br&gt;MotionEvent.ACTION_POINTER_UP  ——–&lt;br&gt;MotionEvent.ACTION_UP ———–手指抬起操作，表示一次触摸操作完成&lt;br&gt;MotionEvent.ACTION_CANCEL     ———-DOWN目标的取消动作&lt;/p&gt;
&lt;h3 id=&#34;Touch-事件流程&#34;&gt;&lt;a href=&#34;#Touch-事件流程&#34; class=&#34;headerlink&#34; title=&#34;Touch 事件流程&#34;&gt;&lt;/a&gt;Touch 事件流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt; 按照Touch的发生顺序，首先是Down事件，而Down事件的处理有决定作用，下图为down事件的处理：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/touchdown.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;move和up的事件处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上图中的TouchTarget我们称之为处理目标，下图为move和up事件的处理过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/touchother.bmp&#34;&gt;&lt;/p&gt;
</content>
        <updated>2013-12-24T02:58:45.000Z</updated>
    </entry>
</feed>

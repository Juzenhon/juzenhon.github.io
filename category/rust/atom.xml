<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>黑色红桃7 • Posts by &#34;rust&#34; category</title>
    <link href="http://example.com" />
    <updated>2018-11-20T12:46:11.000Z</updated>
    <category term="test_tag" />
    <entry>
        <id>http://example.com/2018-11-20-rust-static/</id>
        <title>rust static详解</title>
        <link rel="alternate" href="http://example.com/2018-11-20-rust-static/"/>
        <content type="html">&lt;h3 id=&#34;static-语法&#34;&gt;&lt;a href=&#34;#static-语法&#34; class=&#34;headerlink&#34; title=&#34;static 语法&#34;&gt;&lt;/a&gt;static 语法&lt;/h3&gt;&lt;figure class=&#34;highlight ada&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs ada&#34;&gt;static mut? IDENTIFER: &lt;span class=&#34;hljs-keyword&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;hljs-type&#34;&gt;(= &lt;/span&gt;Expresssion)?;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中mut可有可无，Expresssion为表达式，可以没有。&lt;/p&gt;
&lt;h3 id=&#34;static与常量有区别&#34;&gt;&lt;a href=&#34;#static与常量有区别&#34; class=&#34;headerlink&#34; title=&#34;static与常量有区别&#34;&gt;&lt;/a&gt;static与常量有区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;static有自己的内存地址，其生命周期是‘static的，常量没有&lt;/li&gt;
&lt;li&gt;所有的对static item的引用指向同一个地址，而每个常量都有自己的地址&lt;/li&gt;
&lt;li&gt;static的类型必须是Sync的，跨线程访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mut-static&#34;&gt;&lt;a href=&#34;#mut-static&#34; class=&#34;headerlink&#34; title=&#34;mut static&#34;&gt;&lt;/a&gt;mut static&lt;/h3&gt;&lt;p&gt;如果一个static item是mut的，并发访问时可能会有问题，所以对他的引用是unsafe的。我们要自己确保他的正确性。&lt;/p&gt;
&lt;h3 id=&#34;static-变量&#34;&gt;&lt;a href=&#34;#static-变量&#34; class=&#34;headerlink&#34; title=&#34;static 变量&#34;&gt;&lt;/a&gt;static 变量&lt;/h3&gt;&lt;p&gt;按照static的语法定义变量时经常遇到这样的错误:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;calls in statics are limited to constant functions, tuple structs and tuple variants&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说上面的Expresssion只是条件的。只能是常量函数，tuple结构等。而不能像Java语言一样 static Object STATIC_OBJ = new Object();&lt;/p&gt;
&lt;p&gt;其中主要的区别在于是static的初始化必须是在编译期可确定的。也就是说其内存大小是在编译期确定的，而Java是在运行时。&lt;/p&gt;
&lt;h3 id=&#34;lazy-static&#34;&gt;&lt;a href=&#34;#lazy-static&#34; class=&#34;headerlink&#34; title=&#34;lazy_static&#34;&gt;&lt;/a&gt;lazy_static&lt;/h3&gt;&lt;p&gt;由于rust static在编译期确定大小的特性，一些rust程序员在编写代码时产生了诸多不便，就有了&lt;a href=&#34;https://github.com/rust-lang-nursery/lazy-static.rs&#34;&gt;lazy_static&lt;/a&gt;这个库。&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;lazy_static! &amp;#123;&lt;br&gt;    &lt;span class=&#34;hljs-keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;ref&lt;/span&gt; HASHMAP: HashMap&amp;lt;&lt;span class=&#34;hljs-built_in&#34;&gt;u32&lt;/span&gt;, &amp;amp;&lt;span class=&#34;hljs-symbol&#34;&gt;&amp;#x27;static&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;str&lt;/span&gt;&amp;gt; = &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; m = HashMap::new();&lt;br&gt;        m.insert(&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;);&lt;br&gt;        m.insert(&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;);&lt;br&gt;        m.insert(&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;);&lt;br&gt;        m&lt;br&gt;    &amp;#125;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;lazy_static是第一次使用时调用初始化，相当于把初始化挪到了运行时。&lt;/p&gt;
&lt;h3 id=&#34;lazy-mut&#34;&gt;&lt;a href=&#34;#lazy-mut&#34; class=&#34;headerlink&#34; title=&#34;lazy_mut&#34;&gt;&lt;/a&gt;lazy_mut&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://docs.rs/lazy_mut/0.1.0/lazy_mut/&#34;&gt;lazy_mut&lt;/a&gt;是用来解决变量延迟初始化的, 也包括static mut。&lt;/p&gt;
</content>
        <updated>2018-11-20T12:46:11.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2018-11-02-cell/</id>
        <title>rust cell 详解</title>
        <link rel="alternate" href="http://example.com/2018-11-02-cell/"/>
        <content type="html">&lt;h2 id=&#34;背景介绍&#34;&gt;&lt;a href=&#34;#背景介绍&#34; class=&#34;headerlink&#34; title=&#34;背景介绍&#34;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/cell/index.html&#34;&gt;https://doc.rust-lang.org/std/cell/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;众所周知，rust的内存安全是基于一个规则，一个对像须满足以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只存在一个可变引用&lt;/li&gt;
&lt;li&gt;有多个不可变引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在写rust代码时，会发现这样的规则在写代码时会受到一定的束缚。于是rust官方出了一个可以灵活解决对像可变性问题的工具cell。&lt;/p&gt;
&lt;h2 id=&#34;cell与Mutex等的不同&#34;&gt;&lt;a href=&#34;#cell与Mutex等的不同&#34; class=&#34;headerlink&#34; title=&#34;cell与Mutex等的不同&#34;&gt;&lt;/a&gt;cell与Mutex等的不同&lt;/h2&gt;&lt;p&gt;诚然我们可以用Mutex, atomic等来解决可变性问题，但cell与mutex有本质的不同。&lt;br&gt;cell是线程安全的（没有实现Sync，不能跨线程访问），Mutex主要用来解决多线程数据竞争的。&lt;/p&gt;
&lt;h2 id=&#34;cell的具体分析&#34;&gt;&lt;a href=&#34;#cell的具体分析&#34; class=&#34;headerlink&#34; title=&#34;cell的具体分析&#34;&gt;&lt;/a&gt;cell的具体分析&lt;/h2&gt;&lt;p&gt;cell的实现分Cell, RefCell, UnsafeCell，还有一个开源实现LazyCell&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#[repr(transparent)]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;Cell&lt;/span&gt;&lt;/span&gt;&amp;lt;T: ?&lt;span class=&#34;hljs-built_in&#34;&gt;Sized&lt;/span&gt;&amp;gt; &amp;#123;&lt;br&gt;    value: UnsafeCell&amp;lt;T&amp;gt;,&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;RefCell&lt;/span&gt;&lt;/span&gt;&amp;lt;T: ?&lt;span class=&#34;hljs-built_in&#34;&gt;Sized&lt;/span&gt;&amp;gt; &amp;#123;&lt;br&gt;    borrow: Cell&amp;lt;BorrowFlag&amp;gt;,&lt;br&gt;    value: UnsafeCell&amp;lt;T&amp;gt;,&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#[repr(transparent)]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;UnsafeCell&lt;/span&gt;&lt;/span&gt;&amp;lt;T: ?&lt;span class=&#34;hljs-built_in&#34;&gt;Sized&lt;/span&gt;&amp;gt; &amp;#123;&lt;br&gt;    value: T,&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;p&gt;从源码上来看Cell和RefCell的内部都是由UnsafeCell来实现的, 要想理解Cell与RefCell就需要先了解UnsafeCell&lt;/p&gt;
&lt;h3 id=&#34;UnsafeCell&#34;&gt;&lt;a href=&#34;#UnsafeCell&#34; class=&#34;headerlink&#34; title=&#34;UnsafeCell&#34;&gt;&lt;/a&gt;UnsafeCell&lt;/h3&gt;&lt;p&gt;UnsafeCell非常简单，有一个重要的方法：&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//返回一个可变指针&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;get&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;) -&amp;gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; T &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;as&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; UnsafeCell&amp;lt;T&amp;gt; &lt;span class=&#34;hljs-keyword&#34;&gt;as&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; T &lt;span class=&#34;hljs-keyword&#34;&gt;as&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; T&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;p&gt;通过一个不可变对像返回一个可变的对像指针，Cell与RefCell正是利用了这个达到相应的目的，前提是他们是线程安全的。&lt;/p&gt;
&lt;h3 id=&#34;Cell&#34;&gt;&lt;a href=&#34;#Cell&#34; class=&#34;headerlink&#34; title=&#34;Cell&#34;&gt;&lt;/a&gt;Cell&lt;/h3&gt;&lt;p&gt;看一下replace,get, set, take等方法，都是基于UnsafeCell返回的可变指针的内存操作&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;replace&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;, val: T) -&amp;gt; T &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-comment&#34;&gt;// SAFETY: This can cause data races if called from a separate thread,&lt;/span&gt;&lt;br&gt;        &lt;span class=&#34;hljs-comment&#34;&gt;// but `Cell` is `!Sync` so this won&amp;#x27;t happen.&lt;/span&gt;&lt;br&gt;        mem::replace(&lt;span class=&#34;hljs-keyword&#34;&gt;unsafe&lt;/span&gt; &amp;#123; &amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;.value.get() &amp;#125;, val)&lt;br&gt;    &amp;#125;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//T: Copy    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;get&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;) -&amp;gt; T &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-comment&#34;&gt;// SAFETY: This can cause data races if called from a separate thread,&lt;/span&gt;&lt;br&gt;        &lt;span class=&#34;hljs-comment&#34;&gt;// but `Cell` is `!Sync` so this won&amp;#x27;t happen.&lt;/span&gt;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;unsafe&lt;/span&gt; &amp;#123; *&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;.value.get() &amp;#125;&lt;br&gt;    &amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;h3 id=&#34;RefCell&#34;&gt;&lt;a href=&#34;#RefCell&#34; class=&#34;headerlink&#34; title=&#34;RefCell&#34;&gt;&lt;/a&gt;RefCell&lt;/h3&gt;&lt;p&gt;Refcell是在Cell的增强版，他在Cell的基础上添加了借用，内部维护着一个借用的标识，在运行时做借用检查。&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;borrow&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;) -&amp;gt; Ref&amp;lt;&lt;span class=&#34;hljs-symbol&#34;&gt;&amp;#x27;_&lt;/span&gt;, T&amp;gt; &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;.try_borrow().expect(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;already mutably borrowed&amp;quot;&lt;/span&gt;)&lt;br&gt;    &amp;#125;&lt;br&gt;    &lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;borrow_mut&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;) -&amp;gt; RefMut&amp;lt;&lt;span class=&#34;hljs-symbol&#34;&gt;&amp;#x27;_&lt;/span&gt;, T&amp;gt; &amp;#123;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;self&lt;/span&gt;.try_borrow_mut().expect(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;already borrowed&amp;quot;&lt;/span&gt;)&lt;br&gt;    &amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;p&gt;主要方法borrow和borrow_mut返回相应的引用对像，当Ref或RefMut销毁时相应的借用关系消除&lt;/p&gt;
&lt;h3 id=&#34;LazyCell&#34;&gt;&lt;a href=&#34;#LazyCell&#34; class=&#34;headerlink&#34; title=&#34;LazyCell&#34;&gt;&lt;/a&gt;LazyCell&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/indiv0/lazycell&#34;&gt;https://github.com/indiv0/lazycell&lt;/a&gt;, 从代码看其和Cell功能类似，用于延迟初始化。&lt;/p&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;LazyCell&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt; &amp;#123;&lt;br&gt;    inner: UnsafeCell&amp;lt;&lt;span class=&#34;hljs-built_in&#34;&gt;Option&lt;/span&gt;&amp;lt;T&amp;gt;&amp;gt;,&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;





</content>
        <updated>2018-11-02T14:39:42.000Z</updated>
    </entry>
</feed>

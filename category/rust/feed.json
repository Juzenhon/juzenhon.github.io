{
    "version": "https://jsonfeed.org/version/1",
    "title": "黑色红桃7 • All posts by \"rust\" category",
    "description": "朱新宏的博客",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2018-11-20-rust-static/",
            "url": "http://example.com/2018-11-20-rust-static/",
            "title": "rust static详解",
            "date_published": "2018-11-22T12:46:11.000Z",
            "content_html": "<h3 id=\"static-语法\"><a href=\"#static-语法\" class=\"headerlink\" title=\"static 语法\"></a>static 语法</h3><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">static mut? IDENTIFER: <span class=\"hljs-keyword\">Type</span> <span class=\"hljs-type\">(= </span>Expresssion)?;<br></code></pre></td></tr></table></figure>\n<p>其中mut可有可无，Expresssion为表达式，可以没有。</p>\n<h3 id=\"static与常量有区别\"><a href=\"#static与常量有区别\" class=\"headerlink\" title=\"static与常量有区别\"></a>static与常量有区别</h3><ul>\n<li>static有自己的内存地址，其生命周期是‘static的，常量没有</li>\n<li>所有的对static item的引用指向同一个地址，而每个常量都有自己的地址</li>\n<li>static的类型必须是Sync的，跨线程访问</li>\n</ul>\n<h3 id=\"mut-static\"><a href=\"#mut-static\" class=\"headerlink\" title=\"mut static\"></a>mut static</h3><p>如果一个static item是mut的，并发访问时可能会有问题，所以对他的引用是unsafe的。我们要自己确保他的正确性。</p>\n<h3 id=\"static-变量\"><a href=\"#static-变量\" class=\"headerlink\" title=\"static 变量\"></a>static 变量</h3><p>按照static的语法定义变量时经常遇到这样的错误:</p>\n<blockquote>\n<p>calls in statics are limited to constant functions, tuple structs and tuple variants</p>\n</blockquote>\n<p>也就是说上面的Expresssion只是条件的。只能是常量函数，tuple结构等。而不能像Java语言一样 static Object STATIC_OBJ = new Object();</p>\n<p>其中主要的区别在于是static的初始化必须是在编译期可确定的。也就是说其内存大小是在编译期确定的，而Java是在运行时。</p>\n<h3 id=\"lazy-static\"><a href=\"#lazy-static\" class=\"headerlink\" title=\"lazy_static\"></a>lazy_static</h3><p>由于rust static在编译期确定大小的特性，一些rust程序员在编写代码时产生了诸多不便，就有了<a href=\"https://github.com/rust-lang-nursery/lazy-static.rs\">lazy_static</a>这个库。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\">lazy_static! &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">ref</span> HASHMAP: HashMap&lt;<span class=\"hljs-built_in\">u32</span>, &amp;<span class=\"hljs-symbol\">&#x27;static</span> <span class=\"hljs-built_in\">str</span>&gt; = &#123;<br>        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> m = HashMap::new();<br>        m.insert(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>);<br>        m.insert(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>);<br>        m.insert(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;baz&quot;</span>);<br>        m<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>lazy_static是第一次使用时调用初始化，相当于把初始化挪到了运行时。</p>\n<h3 id=\"lazy-mut\"><a href=\"#lazy-mut\" class=\"headerlink\" title=\"lazy_mut\"></a>lazy_mut</h3><p><a href=\"https://docs.rs/lazy_mut/0.1.0/lazy_mut/\">lazy_mut</a>是用来解决变量延迟初始化的, 也包括static mut。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-20-rust-tokio0-1/",
            "url": "http://example.com/2018-11-20-rust-tokio0-1/",
            "title": "tokio0.1分析",
            "date_published": "2018-11-20T11:28:18.000Z",
            "content_html": "<h1 id=\"关于-tokio\"><a href=\"#关于-tokio\" class=\"headerlink\" title=\"关于 tokio\"></a>关于 tokio</h1><h2 id=\"what-is-tokio\"><a href=\"#what-is-tokio\" class=\"headerlink\" title=\"what is tokio\"></a>what is tokio</h2><p>tokio是一个rust语言的异步编程框架，是一个基于事件驱动和非阻塞I/O的框架。在上层设计上，它提供了一些主要组件：</p>\n<ul>\n<li>多线程，任务窃取(work-stealing)的task <a href=\"https://tokio-rs.github.io/tokio/tokio/runtime/index.html\">scheduler</a> (runtime)</li>\n<li>由操作系统的事件队列（epoll,kqueue,IOCP等）支撑的<a href=\"https://docs.rs/tokio/0.1.1/tokio/reactor/index.html\">reactor</a></li>\n<li>异步<a href=\"https://docs.rs/tokio/0.1/tokio/net/index.html\">TCP和UDP</a>套接字</li>\n</ul>\n<h2 id=\"tokio-优势\"><a href=\"#tokio-优势\" class=\"headerlink\" title=\"tokio 优势\"></a>tokio 优势</h2><ul>\n<li>零成本抽象，tokio是基于futures的。</li>\n<li>并发，tokio提供了多线程，work-stealing,scheduler。在现代多核cpu的情况下你可以充分利用他们提高应用的性能。</li>\n<li>非阻塞，高性能，当涉及到网络时，tokio会非常有效的使用系统，如linux上的<a href=\"http://man7.org/linux/man-pages/man7/epoll.7.html\">epoll</a>,bsd平台的<a href=\"https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\">kqueue</a>,Windows的<a href=\"https://docs.microsoft.com/en-us/windows/desktop/fileio/i-o-completion-ports\">I/O completion ports</a>,他们可以在单线程中进行多路复用，批量接收系统通知，减少系统调用。<blockquote>\n<p> Because Tokio uses a poll based model, the problem mostly just goes away. Producers are lazy by default. They will not produce any data unless the consumer asks them to. This is built into Tokio’s foundation.</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>Reliable，api清晰易用，使用rust不会有太多的内存问题。</p>\n</li>\n<li><p>BackPressure，在基于push的系统中，当生产者生产数据的速度超过了消费者消费的速度，数据就会暂存在内存中。除非生产者停止生产，否则系统就会因为内存耗尽而崩溃。消费者通知生产者放慢生产的能力就是BackPressure。在tokio中利用<a href=\"https://tokio.rs/docs/getting-started/futures/#poll-based-futures\">poll</a>的方式很好的解决了这个问题。</p>\n</li>\n<li><p>Cancellation</p>\n<blockquote>\n<p>Because of Tokio’s poll based model, computations do no work unless they are polled. Dependents of that computation hold a future representing the result of that computation. If the result is no longer needed, the future is dropped. At this point, the computation will no longer be polled and thus perform no more work.</p>\n</blockquote>\n<blockquote>\n<p>Thanks to Rust’s ownership model, the computation is able to implement drop handles to detect the future being dropped. This allows it to perform any necessary cleanup work.</p>\n</blockquote>\n</li>\n<li><p>轻量级框架</p>\n</li>\n<li><p>没有垃圾回收</p>\n</li>\n</ul>\n<h2 id=\"tokio的结构\"><a href=\"#tokio的结构\" class=\"headerlink\" title=\"tokio的结构\"></a>tokio的结构</h2><p>结构总体抽象为Futures,Tasks和Executor,并提供了提供了Timer等基础设施。tokio快速，可靠，且可扩展。<br>Tokio 是一个事件驱动的非阻塞I/O框架，用于rust编程语言编写异步应用。在高层设计上，这些组件提供了很好的抽象，大大简化了编码工作。</p>\n<h3 id=\"tokio的依赖\"><a href=\"#tokio的依赖\" class=\"headerlink\" title=\"tokio的依赖\"></a>tokio的依赖</h3><p>tokio主要的依赖有futures,mio(基于异步事件通知的高性能I/O库)</p>\n<h4 id=\"mio\"><a href=\"#mio\" class=\"headerlink\" title=\"mio\"></a>mio</h4><p>参见mio模块</p>\n<h4 id=\"future\"><a href=\"#future\" class=\"headerlink\" title=\"future\"></a>future</h4><p>参见future模块</p>\n<h3 id=\"tokio分析\"><a href=\"#tokio分析\" class=\"headerlink\" title=\"tokio分析\"></a>tokio分析</h3><p>tokio主要分clock,codec,executor,fs,io,net,reactor,runtime,timer这几个模块。这里挑几个主要介绍。</p>\n<h4 id=\"executor\"><a href=\"#executor\" class=\"headerlink\" title=\"executor\"></a>executor</h4><p>executor的作用是执行任务。在tokio执行模型中，futures是懒模式，也就是说当一个future被创建时是不会执行的，为了让他工作，我们要把化丢到一个executor里。在executor里的future就叫做task。<br>当task被通知时，exectuor确保future的poll方法会被执行。executor一般有有两种模型，单线程和多线程，在runtime模块中都有实现。</p>\n<h5 id=\"DefaultExecutor\"><a href=\"#DefaultExecutor\" class=\"headerlink\" title=\"DefaultExecutor\"></a>DefaultExecutor</h5><p><a href=\"https://docs.rs/tokio-executor/0.1.5/src/tokio_executor/global.rs.html#18-20\">DefaultExecutor</a>实现了<a href=\"https://docs.rs/tokio/0.1/tokio/executor/trait.Executor.html\">tokio::executor::Executor</a>,同样也实现了future的Executor trait这样就可以和futures库联系起来。<br>我们来分析一下他的源码：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Debug, Clone)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">DefaultExecutor</span></span> &#123;<br>    _dummy: (),<br>&#125;<br><br><span class=\"hljs-keyword\">impl</span> DefaultExecutor &#123;<br>   <br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">current</span></span>() -&gt; DefaultExecutor &#123;<br>        DefaultExecutor &#123;<br>            _dummy: (),<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-meta\">#[inline]</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_current</span></span>&lt;F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> Executor) -&gt; R, R&gt;(f: F) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;R&gt; &#123;<br>        EXECUTOR.with(|current_executor| &#123;<br>            <span class=\"hljs-keyword\">match</span> current_executor.replace(State::Active) &#123;<br>                State::Ready(executor_ptr) =&gt; &#123;<br>                    <span class=\"hljs-keyword\">let</span> executor = <span class=\"hljs-keyword\">unsafe</span> &#123; &amp;<span class=\"hljs-keyword\">mut</span> *executor_ptr &#125;;<br>                    <span class=\"hljs-keyword\">let</span> result = f(executor);<br>                    current_executor.set(State::Ready(executor_ptr));<br>                    <span class=\"hljs-literal\">Some</span>(result)<br>                &#125;,<br>                State::Empty | State::Active =&gt; <span class=\"hljs-literal\">None</span>,<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Clone, Copy)]</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">State</span></span> &#123;<br>    <span class=\"hljs-comment\">// default executor not defined</span><br>    Empty,<br>    <span class=\"hljs-comment\">// default executor is defined and ready to be used</span><br>    Ready(*<span class=\"hljs-keyword\">mut</span> Executor),<br>    <span class=\"hljs-comment\">// default executor is currently active (used to detect recursive calls)</span><br>    Active<br>&#125;<br><br><span class=\"hljs-comment\">/// Thread-local tracking the current executor</span><br>thread_local!(<span class=\"hljs-keyword\">static</span> EXECUTOR: Cell&lt;State&gt; = Cell::new(State::Empty));<br></code></pre></td></tr></table></figure>\n\n<p>从源码看DefaultExecutor并没有具体的实现，只是一个空壳。每个线程都有一个指针指向一个设置的Executor，使用的是线程本地变量保存。</p>\n<p><em><strong>那么如何设置该Executor呢？</strong></em></p>\n<p>使用<a href=\"https://docs.rs/tokio-executor/0.1.5/src/tokio_executor/global.rs.html#158-194\">with_default</a>方法，他有一个<a href=\"https://docs.rs/crate/tokio-executor/0.1.5/source/src/enter.rs\">Enter</a>类型的变量，代表的是executor的上下文</p>\n<h2 id=\"Reactor\"><a href=\"#Reactor\" class=\"headerlink\" title=\"Reactor\"></a>Reactor</h2><p>reactor主要用来管理Event loop,reactor用来接收从操作系统的事件(epoll,kqueue,IOCP,…),然后转发给等待的tasks。reactor可以看做是操作系统与futures模型之间的桥梁。<br>reactor从操作系统接收事件后会通知到executor。</p>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> tokio::prelude::*;<br><span class=\"hljs-keyword\">use</span> tokio::net::TcpStream;<br><br><span class=\"hljs-keyword\">let</span> addr = <span class=\"hljs-string\">&quot;93.184.216.34:9243&quot;</span>.parse().unwrap();<br><br><span class=\"hljs-keyword\">let</span> connect_future = TcpStream::connect(&amp;addr);<br><br><span class=\"hljs-keyword\">let</span> task = connect_future<br>    .and_then(|socket| &#123;<br>        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;successfully connected&quot;</span>);<br>        <span class=\"hljs-literal\">Ok</span>(())<br>    &#125;)<br>    .map_err(|e| <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;failed to connect; err=&#123;:?&#125;&quot;</span>, e));<br><br>tokio::run(task);<br></code></pre></td></tr></table></figure>\n<p>调用connect方法后，会立即返回一个ConnectFuture，并不会阻塞当前线程。<br>run方法执行后，会把task放到threadpool中，task会执行一次返回NotReady,此时会放回threadpool等待通知再次执行。<br>当tcp连接建立后，reactor会从操作系统收到相应的事件，并通知threadpool task可以再次执行。</p>\n<p>以上代码并没有涉及到Reactor，是因为他包装在了run方法内，我们稍后分析。</p>\n<h3 id=\"reactor源码分析\"><a href=\"#reactor源码分析\" class=\"headerlink\" title=\"reactor源码分析\"></a><a href=\"https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/lib.rs.html#88-96\">reactor源码分析</a></h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reactor</span></span> &#123;<br>    <span class=\"hljs-comment\">/// Reuse the `mio::Events` value across calls to poll.</span><br>    events: mio::Events,<br><br>    <span class=\"hljs-comment\">/// State shared between the reactor and the handles.</span><br>    inner: Arc&lt;Inner&gt;,<br><br>    _wakeup_registration: mio::Registration,<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inner</span></span> &#123;<br>    <span class=\"hljs-comment\">/// The underlying system event queue.</span><br>    io: mio::Poll,<br><br>    <span class=\"hljs-comment\">/// ABA guard counter</span><br>    next_aba_guard: AtomicUsize,<br><br>    <span class=\"hljs-comment\">/// Dispatch slabs for I/O and futures events</span><br>    io_dispatch: RwLock&lt;Slab&lt;ScheduledIo&gt;&gt;,<br><br>    <span class=\"hljs-comment\">/// Used to wake up the reactor from a call to `turn`</span><br>    wakeup: mio::SetReadiness<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ScheduledIo</span></span> &#123;<br>    aba_guard: <span class=\"hljs-built_in\">usize</span>,<br>    readiness: AtomicUsize,<br>    reader: AtomicTask,<br>    writer: AtomicTask,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们看到了熟悉的东西，mio::Events和mio::Poll这两个。<br>Reactor中有几个主要的方法：</p>\n<ol>\n<li>handle –&gt; Handle 返回该Reactor的一个句柄<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\"><span class=\"hljs-meta\">#[derive(Clone)]</span><br>struct <span class=\"hljs-class\">HandlePriv </span>&#123;<br><span class=\"hljs-symbol\">    inner:</span> Weak<span class=\"hljs-params\">&lt;Inner&gt;</span>,<br>&#125;<br><br></code></pre></td></tr></table></figure></li>\n<li>set_fallback</li>\n<li>turn<br> 从源码中我们可以看到他调用了mio::Poll的poll方法，<strong>并做了事件分发</strong>。</li>\n<li>is_idle</li>\n<li>background –&gt; Result&lt;Background,Error&gt;<br> 在一个后台线程运行该Reactor,通过返回的Background可以控制Reactor。</li>\n<li>impl Park<br> 阻塞当前线程，等待事件发生。</li>\n</ol>\n<h4 id=\"Reactor的Park与UnPark\"><a href=\"#Reactor的Park与UnPark\" class=\"headerlink\" title=\"Reactor的Park与UnPark\"></a>Reactor的Park与UnPark</h4><p>使用的是mio::Registration中机制</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">park</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; io::<span class=\"hljs-built_in\">Result</span>&lt;()&gt; &#123;<br>        <span class=\"hljs-keyword\">self</span>.turn(<span class=\"hljs-literal\">None</span>)?;<br>        <span class=\"hljs-literal\">Ok</span>(())<br>    &#125;<br><span class=\"hljs-comment\">//turn调用 的poll方法    </span><br>    <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">unpark</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-keyword\">ref</span> h) = <span class=\"hljs-keyword\">self</span>.inner &#123;<br>            h.wakeup();<br>        &#125;<br>    &#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">wakeup</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(handle) = <span class=\"hljs-keyword\">self</span>.as_priv() &#123;<br>            handle.wakeup();<br>        &#125;<br>    &#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">wakeup</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(inner) = <span class=\"hljs-keyword\">self</span>.inner() &#123;<br>            inner.wakeup.set_readiness(mio::Ready::readable()).unwrap();<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"Registration\"><a href=\"#Registration\" class=\"headerlink\" title=\"Registration\"></a>Registration</h4><p>一种注册到Reactor中的IO资源，他可以从Reactor接受任务通知。通过register把Evented注册到Reactor中。一个Registeration代表两个stream，一个用于读另一个用于写。</p>\n<h5 id=\"Registration到Reactor的注册过程：\"><a href=\"#Registration到Reactor的注册过程：\" class=\"headerlink\" title=\"Registration到Reactor的注册过程：\"></a>Registration到Reactor的注册过程：</h5><p>1.Registration的<a href=\"https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/registration.rs.html#114-117\">register</a>方法中执行register2方法<br>2. register2中199行根据Evented和Reactor的handle构造了一个Registration的Inner<br>3. 我们可以下构造过程代码419行，425行调用了Reactor中的方法 <a href=\"https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/lib.rs.html#636-663\">add_source</a><br>4. add_source方法的657行调用了poll的注册方法</p>\n<h5 id=\"Registration的通知过程\"><a href=\"#Registration的通知过程\" class=\"headerlink\" title=\"Registration的通知过程\"></a>Registration的通知过程</h5><ol>\n<li>Reactor的<a href=\"https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/lib.rs.html#324-327\">turn</a>方法为入口,他调用了poll方法。</li>\n<li>跳到349行poll方法，352行调用了mio::Poll的poll方法，这里会阻塞，返回事件后370判断是内部唤醒事件还是其他事件，其他事件调用dispatch方法。</li>\n<li>388行 dispatch方法先获取读锁，用token为key取出相应的task想关记录，匹配事件是否对的上，最后调用task.notify()。</li>\n</ol>\n<p> Registration中有两个重要的方法，poll_read_ready,poll_write_ready，他们读取Reactor相关的事件。利用这两个函数可以生成两个Future。</p>\n<h4 id=\"PollEvented\"><a href=\"#PollEvented\" class=\"headerlink\" title=\"PollEvented\"></a>PollEvented</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PollEvented</span></span>&lt;E: Evented&gt; &#123;<br>    io: <span class=\"hljs-built_in\">Option</span>&lt;E&gt;,<br>    inner: Inner,<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inner</span></span> &#123;<br>    registration: Registration,<br><br>    <span class=\"hljs-comment\">/// Currently visible read readiness</span><br>    read_readiness: AtomicUsize,<br><br>    <span class=\"hljs-comment\">/// Currently visible write readiness</span><br>    write_readiness: AtomicUsize,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从代码可以看出了，他关联了Registration。他进一步包装了Evented和Registration。PollEvented实现了Read AsyncRead和Write AsyncWrite trait,对上层使用更友好了。</p>\n<h2 id=\"timer\"><a href=\"#timer\" class=\"headerlink\" title=\"timer\"></a>timer</h2><p>时间相关的工具模块，该模块主要包括以下几个功能：</p>\n<ol>\n<li>Delay,一个future在指定的时间后完成</li>\n<li>Interval ,一个Stream,每隔固定的时间产生一个值，值为时间从开始到现在的时间点。</li>\n<li>Timeout，包装了一个future或Stream，设置一个上限时间，如果在指定的时间内不能完成则会被cancelled或返回error。</li>\n<li><a href=\"https://docs.rs/tokio/0.1/tokio/timer/delay_queue/struct.DelayQueue.html\">DelayQueue</a>, 一个队列，通过insert,inser_at等函数可以操作这个队列。也可以当做一个Stream，当item的请求过期后就会被返回。</li>\n<li><a href=\"https://docs.rs/tokio-timer/0.2.7/tokio_timer/timer/struct.Timer.html\">Timer</a> Timer跟踪管理时间的状态，当Delay的deadline到时会通知它。<br>创建一个Timer,使用park方法阻塞当前线程，通过handle()获取Timer的Handle, Handle可以用于创建Delay</li>\n</ol>\n<h2 id=\"runtime\"><a href=\"#runtime\" class=\"headerlink\" title=\"runtime\"></a><a href=\"https://docs.rs/tokio/0.1/tokio/runtime/index.html\">runtime</a></h2><p>使用tokio时需要Reactor,executor,timer这三者的支持。我们可以手动的把这三者关联起来，但可能比较复杂。如果不想麻烦，我们可以用runtime来把这三者串联并管理起来。</p>\n<p>创建runtime时内部做了以下工作：</p>\n<ul>\n<li>开起一个后台线程执行Reactor,而0.1.11版本以后改为每个工作线程有一个Reactor</li>\n<li>开起一个ThreadPoll用于执行futures</li>\n<li>每个工作线程运行一个Timer实例</li>\n</ul>\n<h3 id=\"runtime的使用\"><a href=\"#runtime的使用\" class=\"headerlink\" title=\"runtime的使用\"></a>runtime的使用</h3><h4 id=\"exapmple\"><a href=\"#exapmple\" class=\"headerlink\" title=\"exapmple\"></a>exapmple</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> tokio::net::TcpListener;<br><br><span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(&amp;addr).unwrap();<br><br><span class=\"hljs-keyword\">let</span> server = listener.incoming()<br>    .map_err(|e| <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;error = &#123;:?&#125;&quot;</span>, e))<br>    .for_each(|socket| &#123;<br>        tokio::spawn(process(socket))<br>    &#125;);<br><br>tokio::run(server);<br></code></pre></td></tr></table></figure>\n<p>可以使用run代替自己创建runtime，run方法会阻塞当前线程直到runtime运行完所有任务。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> tokio::runtime::Runtime;<br><span class=\"hljs-keyword\">use</span> tokio::net::TcpListener;<br><br><span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(&amp;addr).unwrap();<br><span class=\"hljs-keyword\">let</span> server = listener.incoming()<br>    .map_err(|e| <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;error = &#123;:?&#125;&quot;</span>, e))<br>    .for_each(|socket| &#123;<br>        tokio::spawn(process(socket))<br>    &#125;);<br><span class=\"hljs-comment\">// Create the runtime</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> rt = Runtime::new().unwrap();<br><br><span class=\"hljs-comment\">// Spawn the server task</span><br>rt.spawn(server);<br><br><span class=\"hljs-comment\">// Wait until the runtime becomes idle and shut it down.</span><br>rt.shutdown_on_idle()<br>    .wait().unwrap();<br></code></pre></td></tr></table></figure>\n<p>我们也可以自己创建runtime，并调用spawn方法，他会把future放到配置的threadpoll中去运行并立即返回。shutdown_on_idle方法会阻塞直到所有任务运行完并关闭。</p>\n<h4 id=\"runtime的配置\"><a href=\"#runtime的配置\" class=\"headerlink\" title=\"runtime的配置\"></a>runtime的配置</h4><p>ThreadPool使用了work-stealing策略，ThreadPool默认每个cpu core开起一个工作线程</p>\n<ol>\n<li>通过Runtime的new方法生成默认配置的</li>\n<li>通过<a href=\"https://docs.rs/tokio/0.1/tokio/runtime/struct.Builder.html\">Builder</a>来构造一个满足你想要的配置的Runtime。<br>主要的配置参数有clock,核心线程数，最大阻塞线程数，线程空闲时的存活时间，线程名，线程栈大小等。</li>\n</ol>\n<h3 id=\"runtime分析\"><a href=\"#runtime分析\" class=\"headerlink\" title=\"runtime分析\"></a>runtime分析</h3><p><a href=\"https://docs.rs/tokio/0.1/src/tokio/runtime/mod.rs.html#221-490\">source</a></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Runtime</span></span> &#123;<br>    inner: <span class=\"hljs-built_in\">Option</span>&lt;Inner&gt;,<br>&#125;<br><br><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inner</span></span> &#123;<br>    <span class=\"hljs-comment\">/// A handle to one of the per-worker reactors.</span><br>    reactor: Handle,<br><br>    <span class=\"hljs-comment\">/// Task execution pool.</span><br>    pool: threadpool::ThreadPool,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从代码可以看出Runtime封装了一个线程池和reactor，但这个reactor在0.1.11版本后就没有用了。<br>下面主要分析一下future的执行过程：</p>\n<p>1.以Runtime 的<a href=\"https://docs.rs/tokio/0.1/src/tokio/runtime/mod.rs.html#342-347\">spawn</a>方法为入口,调用了threadpool的sender方法返回一个<a href=\"https://tokio-rs.github.io/tokio/tokio_threadpool/struct.Sender.html\">Sender</a>，并调用其<a href=\"https://tokio-rs.github.io/tokio/src/tokio_threadpool/sender.rs.html#128-133\">spawn</a>方法。</p>\n<ol start=\"2\">\n<li>Sender是一个Executor,spawn中主要做了三件事：<ol>\n<li>准备工作，容量及状态检查</li>\n<li>new 一个Task</li>\n<li>调用pool的<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/pool/mod.rs\">submit_to_random</a>方法，把这个task随机提交到某个worker中。</li>\n</ol>\n</li>\n</ol>\n<p>接下来我们找到工作线程的<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/pool/mod.rs\">入口</a>，Pool的spawn_thread方法，里面调用 了worker的do_run:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">do_run</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">bool</span> &#123;<br>        <span class=\"hljs-comment\">// Create another worker... It&#x27;s ok, this is just a new type around</span><br>        <span class=\"hljs-comment\">// `Pool` that is expected to stay on the current thread.</span><br>        CURRENT_WORKER.with(|c| &#123;<br>            c.set(<span class=\"hljs-keyword\">self</span> <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _);<br><br>            <span class=\"hljs-keyword\">let</span> inner = <span class=\"hljs-keyword\">self</span>.inner.clone();<br>            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> sender = Sender &#123; inner &#125;;<br><br>            <span class=\"hljs-comment\">// Enter an execution context</span><br>            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> enter = tokio_executor::enter().unwrap();<br><br>            tokio_executor::with_default(&amp;<span class=\"hljs-keyword\">mut</span> sender, &amp;<span class=\"hljs-keyword\">mut</span> enter, |enter| &#123;<br>                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-keyword\">ref</span> callback) = <span class=\"hljs-keyword\">self</span>.inner.config.around_worker &#123;<br>                    callback.call(<span class=\"hljs-keyword\">self</span>, enter);<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    <span class=\"hljs-keyword\">self</span>.run();<br>                &#125;<br>            &#125;);<br>        &#125;);<br><br>        <span class=\"hljs-comment\">// Can&#x27;t be in blocking mode and finalization mode</span><br>        <span class=\"hljs-built_in\">debug_assert!</span>(!<span class=\"hljs-keyword\">self</span>.is_blocking.get() || !<span class=\"hljs-keyword\">self</span>.should_finalize.get());<br><br>        <span class=\"hljs-keyword\">self</span>.is_blocking.get()<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>来看一下  <strong>tokio_reactor::with_default:</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\">thread_local!(<span class=\"hljs-keyword\">static</span> CURRENT_REACTOR: RefCell&lt;<span class=\"hljs-built_in\">Option</span>&lt;HandlePriv&gt;&gt; = RefCell::new(<span class=\"hljs-literal\">None</span>));<br><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_default</span></span>&lt;F, R&gt;(handle: &amp;Handle, enter: &amp;<span class=\"hljs-keyword\">mut</span> Enter, f: F) -&gt; R<br><span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> Enter) -&gt; R<br>&#123;<br>    <span class=\"hljs-comment\">// Ensure that the executor is removed from the thread-local context</span><br>    <span class=\"hljs-comment\">// when leaving the scope. This handles cases that involve panicking.</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reset</span></span>;<br><br>    <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Reset &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) &#123;<br>            CURRENT_REACTOR.with(|current| &#123;<br>                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> current = current.borrow_mut();<br>                *current = <span class=\"hljs-literal\">None</span>;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// This ensures the value for the current reactor gets reset even if there</span><br>    <span class=\"hljs-comment\">// is a panic.</span><br>    <span class=\"hljs-keyword\">let</span> _r = Reset;<br><br>    CURRENT_REACTOR.with(|current| &#123;<br>        &#123;<br>            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> current = current.borrow_mut();<br><br>            <span class=\"hljs-built_in\">assert!</span>(current.is_none(), <span class=\"hljs-string\">&quot;default Tokio reactor already set \\</span><br><span class=\"hljs-string\">                    for execution context&quot;</span>);<br><br>            <span class=\"hljs-keyword\">let</span> handle = <span class=\"hljs-keyword\">match</span> handle.as_priv() &#123;<br>                <span class=\"hljs-literal\">Some</span>(handle) =&gt; handle,<br>                <span class=\"hljs-literal\">None</span> =&gt; &#123;<br>                    <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">&quot;`handle` does not reference a reactor&quot;</span>);<br>                &#125;<br>            &#125;;<br><br>            *current = <span class=\"hljs-literal\">Some</span>(handle.clone());<br>        &#125;<br><br>        f(enter)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>实际是调用了里面的闭包，根据config.around_worker里是否设置了callback来决定是调用callback还是调用了run方法。我们找到around_worker的设置地方，在Runtime的Builder的build方法中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">let</span> pool = <span class=\"hljs-keyword\">self</span>.threadpool_builder<br>            .around_worker(<span class=\"hljs-keyword\">move</span> |w, enter| &#123;<br>                <span class=\"hljs-keyword\">let</span> index = w.id().to_usize();<br><br>                tokio_reactor::with_default(&amp;reactor_handles[index], enter, |enter| &#123;<br>                    clock::with_default(&amp;clock, enter, |enter| &#123;<br>                        timer::with_default(&amp;timer_handles[index], enter, |_| &#123;<br>                            w.run();<br>                        &#125;);<br>                    &#125;)<br>                &#125;);<br>            &#125;)<br>        ..............<br>            .build();<br></code></pre></td></tr></table></figure>\n\n<p>来看一下 <strong>clock::with_default 与上面同样的套路：</strong><br> <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"> thread_local!(<span class=\"hljs-keyword\">static</span> CLOCK: Cell&lt;<span class=\"hljs-built_in\">Option</span>&lt;*<span class=\"hljs-keyword\">const</span> Clock&gt;&gt; = Cell::new(<span class=\"hljs-literal\">None</span>));<br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_default</span></span>&lt;F, R&gt;(clock: &amp;Clock, enter: &amp;<span class=\"hljs-keyword\">mut</span> Enter, f: F) -&gt; R<br><span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> Enter) -&gt; R<br>&#123;<br>    CLOCK.with(|cell| &#123;<br>        <span class=\"hljs-built_in\">assert!</span>(cell.get().is_none(), <span class=\"hljs-string\">&quot;default clock already set for execution context&quot;</span>);<br><br>        <span class=\"hljs-comment\">// Ensure that the clock is removed from the thread-local context</span><br>        <span class=\"hljs-comment\">// when leaving the scope. This handles cases that involve panicking.</span><br>        <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reset</span></span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt;(&amp;<span class=\"hljs-symbol\">&#x27;a</span> Cell&lt;<span class=\"hljs-built_in\">Option</span>&lt;*<span class=\"hljs-keyword\">const</span> Clock&gt;&gt;);<br><br>        <span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Reset&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; &#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) &#123;<br>                <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>.set(<span class=\"hljs-literal\">None</span>);<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">let</span> _reset = Reset(cell);<br><br>        cell.set(<span class=\"hljs-literal\">Some</span>(clock <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> Clock));<br><br>        f(enter)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<p>再找到 <strong>timer::with_default也是同样的套路：</strong><br> <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"> thread_local!(<span class=\"hljs-keyword\">static</span> CURRENT_TIMER: RefCell&lt;<span class=\"hljs-built_in\">Option</span>&lt;HandlePriv&gt;&gt; = RefCell::new(<span class=\"hljs-literal\">None</span>));<br> <br> <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_default</span></span>&lt;F, R&gt;(handle: &amp;Handle, enter: &amp;<span class=\"hljs-keyword\">mut</span> Enter, f: F) -&gt; R<br><span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> Enter) -&gt; R<br>&#123;<br>    <span class=\"hljs-comment\">// Ensure that the timer is removed from the thread-local context</span><br>    <span class=\"hljs-comment\">// when leaving the scope. This handles cases that involve panicking.</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reset</span></span>;<br><br>    <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Reset &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) &#123;<br>            CURRENT_TIMER.with(|current| &#123;<br>                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> current = current.borrow_mut();<br>                *current = <span class=\"hljs-literal\">None</span>;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// This ensures the value for the current timer gets reset even if there is</span><br>    <span class=\"hljs-comment\">// a panic.</span><br>    <span class=\"hljs-keyword\">let</span> _r = Reset;<br><br>    CURRENT_TIMER.with(|current| &#123;<br>        &#123;<br>            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> current = current.borrow_mut();<br><br>            <span class=\"hljs-built_in\">assert!</span>(current.is_none(), <span class=\"hljs-string\">&quot;default Tokio timer already set \\</span><br><span class=\"hljs-string\">                    for execution context&quot;</span>);<br><br>            <span class=\"hljs-keyword\">let</span> handle = handle.as_priv()<br>                .unwrap_or_else(|| <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">&quot;`handle` does not reference a timer&quot;</span>));<br><br>            *current = <span class=\"hljs-literal\">Some</span>(handle.clone());<br>        &#125;<br><br>        f(enter)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><br> 最后可以看到运行的是Worker的<a href=\"https://tokio-rs.github.io/tokio/src/tokio_threadpool/worker/mod.rs.html#219-292\">run</a>方法，run方法根据执行的结果进行了状态调整。对看247行try_run_task()方法:<br> <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[inline]</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">try_run_task</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, notify: &amp;Arc&lt;Notifier&gt;) -&gt; <span class=\"hljs-built_in\">bool</span> &#123;<br>       <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.try_run_owned_task(notify) &#123;<br>           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>       &#125;<br><br>       <span class=\"hljs-keyword\">self</span>.try_steal_task(notify)<br>   &#125;<br></code></pre></td></tr></table></figure></p>\n<p> 先进入395行try_run_owned_task方法的实现，调用了458行的run_task方法：<br> <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run_task</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, task: Arc&lt;Task&gt;, notify: &amp;Arc&lt;Notifier&gt;) &#123;<br>       <span class=\"hljs-keyword\">use</span> task::Run::*;<br>       <span class=\"hljs-keyword\">let</span> run = <span class=\"hljs-keyword\">self</span>.run_task2(&amp;task, notify);<br>       <span class=\"hljs-keyword\">match</span> run &#123;<br>           Idle =&gt; &#123;&#125;<br>           Schedule =&gt; &#123;<br>               <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.is_blocking.get() &#123;<br>                   <span class=\"hljs-keyword\">self</span>.pool.submit_external(task, &amp;<span class=\"hljs-keyword\">self</span>.pool);<br>               &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                   <span class=\"hljs-keyword\">self</span>.entry().push_internal(task);<br>               &#125;<br>           &#125;<br>           Complete =&gt; &#123;<br>               <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> state: pool::State = <span class=\"hljs-keyword\">self</span>.pool.state.load(Acquire).into();<br><br>               <span class=\"hljs-keyword\">loop</span> &#123;<br>                   <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> next = state;<br>                   next.dec_num_futures();<br><br>                   <span class=\"hljs-keyword\">let</span> actual = <span class=\"hljs-keyword\">self</span>.pool.state.compare_and_swap(<br>                       state.into(), next.into(), AcqRel).into();<br><br>                   <span class=\"hljs-keyword\">if</span> actual == state &#123;<br>                       trace!(<span class=\"hljs-string\">&quot;task complete; state=&#123;:?&#125;&quot;</span>, next);<br><br>                       <span class=\"hljs-keyword\">if</span> state.num_futures() == <span class=\"hljs-number\">1</span> &#123;<br>                           <span class=\"hljs-keyword\">if</span> next.is_terminated() &#123;<br>                               <span class=\"hljs-keyword\">self</span>.pool.terminate_sleeping_workers();<br>                           &#125;<br>                       &#125;<br>                       <span class=\"hljs-keyword\">return</span>;<br>                   &#125;<br><br>                   state = actual;<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><br>调用了runtask2方法并对结果做了处理。跟踪到最后一行task.run(),切换到<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/task/mod.rs\">task.run</a>,我们看到task内有一个类型是UnsafeCell&lt;Option&lt;Spawn<BoxFuture>&gt;&gt;,这个就是future实例了。<br>切换到run方法，看以看到他调用了Spawn的<a href=\"https://docs.rs/tokio/0.1/tokio/prelude/task/struct.Spawn.html#method.poll_future_notify\">poll_future_notify</a>方法。这个方法在Future中讲过，最终调用了future的poll方法。</p>\n<h3 id=\"ThreadPool中task的notify\"><a href=\"#ThreadPool中task的notify\" class=\"headerlink\" title=\"ThreadPool中task的notify\"></a>ThreadPool中task的notify</h3><p>找到<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/task/mod.rs\">notify</a>方法</p>\n<pre><code class=\"rust\"> /// Notify the task\n    pub fn notify(me: Arc&lt;Task&gt;, pool: &amp;Arc&lt;Pool&gt;) &#123;\n        if me.schedule() &#123;\n            let _ = pool.submit(me, pool);\n        &#125;\n    &#125;\n</code></pre>\n<p>先判断一下自己的当前状态，然后通过pool把自己提交到线程池中，进入<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/pool/mod.rs\">submit</a>方法，可以看到熟悉的流程了。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-17-rust-mio-md/",
            "url": "http://example.com/2018-11-17-rust-mio-md/",
            "title": "rust mio",
            "date_published": "2018-11-17T13:24:58.000Z",
            "content_html": "<h2 id=\"mio-简介\"><a href=\"#mio-简介\" class=\"headerlink\" title=\"mio 简介\"></a>mio 简介</h2><p>一个高性能的底层IO库，提供了非阻塞的API,事件通知机制，和一些其他构建高性能应用所需要的工具。</p>\n<p>当前支持的平台有：</p>\n<ul>\n<li>linux</li>\n<li>OS X</li>\n<li>Windows</li>\n<li>FreeBSD</li>\n<li>NetBSD</li>\n<li>Android</li>\n<li>IOS</li>\n</ul>\n<h2 id=\"mio的使用\"><a href=\"#mio的使用\" class=\"headerlink\" title=\"mio的使用\"></a>mio的使用</h2><p>创建一个<a href=\"https://docs.rs/mio/0.6.16/mio/struct.Poll.html\">Poll</a>，Poll会从OS是读取你感兴趣的事件放在<a href=\"https://docs.rs/mio/0.6.16/mio/struct.Events.html\">Events</a>中,然后你可以处理这些IO事件。</p>\n<p>他的使用方式和epoll非常像。</p>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> mio::*;<br><span class=\"hljs-keyword\">use</span> mio::net::&#123;TcpListener, TcpStream&#125;;<br><br><span class=\"hljs-comment\">// Setup some tokens to allow us to identify which event is</span><br><span class=\"hljs-comment\">// for which socket.</span><br><span class=\"hljs-keyword\">const</span> SERVER: Token = Token(<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-keyword\">const</span> CLIENT: Token = Token(<span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-keyword\">let</span> addr = <span class=\"hljs-string\">&quot;127.0.0.1:13265&quot;</span>.parse().unwrap();<br><br><span class=\"hljs-comment\">// Setup the server socket</span><br><span class=\"hljs-keyword\">let</span> server = TcpListener::bind(&amp;addr).unwrap();<br><br><span class=\"hljs-comment\">// Create a poll instance</span><br><span class=\"hljs-keyword\">let</span> poll = Poll::new().unwrap();<br><br><span class=\"hljs-comment\">// Start listening for incoming connections</span><br>poll.register(&amp;server, SERVER, Ready::readable(),<br>              PollOpt::edge()).unwrap();<br><br><span class=\"hljs-comment\">// Setup the client socket</span><br><span class=\"hljs-keyword\">let</span> sock = TcpStream::connect(&amp;addr).unwrap();<br><br><span class=\"hljs-comment\">// Register the socket</span><br>poll.register(&amp;sock, CLIENT, Ready::readable(),<br>              PollOpt::edge()).unwrap();<br><br><span class=\"hljs-comment\">// Create storage for events</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> events = Events::with_capacity(<span class=\"hljs-number\">1024</span>);<br><br><span class=\"hljs-keyword\">loop</span> &#123;<br>    poll.poll(&amp;<span class=\"hljs-keyword\">mut</span> events, <span class=\"hljs-literal\">None</span>).unwrap();<br><br>    <span class=\"hljs-keyword\">for</span> event <span class=\"hljs-keyword\">in</span> events.iter() &#123;<br>        <span class=\"hljs-keyword\">match</span> event.token() &#123;<br>            SERVER =&gt; &#123;<br>                <span class=\"hljs-comment\">// Accept and drop the socket immediately, this will close</span><br>                <span class=\"hljs-comment\">// the socket and notify the client of the EOF.</span><br>                <span class=\"hljs-keyword\">let</span> _ = server.accept();<br>            &#125;<br>            CLIENT =&gt; &#123;<br>                <span class=\"hljs-comment\">// The server just shuts down the socket, let&#x27;s just exit</span><br>                <span class=\"hljs-comment\">// from our event loop.</span><br>                <span class=\"hljs-keyword\">return</span>;<br>            &#125;<br>            _ =&gt; <span class=\"hljs-built_in\">unreachable!</span>(),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"mio分析\"><a href=\"#mio分析\" class=\"headerlink\" title=\"mio分析\"></a>mio分析</h2><p>mio结构相对比较简单，分event和net两个module,加和Registration相关的类。</p>\n<h3 id=\"event-module\"><a href=\"#event-module\" class=\"headerlink\" title=\"event module\"></a>event module</h3><p>struct Event 代表一个产生的事件<br>struct Events 代表事件的集合，可生成迭代器使用</p>\n<p>evented trait 主要用于往Poll里注册感兴趣的事件。</p>\n<h3 id=\"net-module\"><a href=\"#net-module\" class=\"headerlink\" title=\"net module\"></a>net module</h3><p>提供了TcpStream,TcpListener,UdpScoket的poll方式的封装。</p>\n<h3 id=\"Registration\"><a href=\"#Registration\" class=\"headerlink\" title=\"Registration\"></a>Registration</h3><p>用于用户空间的Poll注册的句柄。Registration实现了Evented,他不能用于系统事件中。<br>一个Registration总是会伴随一个SetReadiness，Registration用于注册到Poll中，调用poll方法后会阻塞，调用SetReadiness的set_readiness方法可以唤醒他。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-16-rust-fut01-md/",
            "url": "http://example.com/2018-11-16-rust-fut01-md/",
            "title": "rust future0.1",
            "date_published": "2018-11-16T10:21:23.000Z",
            "content_html": "<h2 id=\"Futures介绍\"><a href=\"#Futures介绍\" class=\"headerlink\" title=\"Futures介绍\"></a>Futures介绍</h2><p>在实际工作中，我们会遇到一些下面的场景：一次数据查询操作，一次向server端的RPC调用，一次timeout等待，一个运行在线程池中的耗时的任务，从socket读取数据等等。<br>我们要想取得运行计算的值，可以使用同步的方法等待返回值，但会遇到一些不便，如主线程不能太耗时，线程阻塞方案实现不方便等。当同步的方式不行时，我们可以考虑异步的方式实现，futures就是一种异步实现方式。具体上说就是future抽像了异步的函数，future的值就是任务的计算结果。</p>\n<p>整个Futures库分为五个大的模块，接下来会分别介绍：</p>\n<h3 id=\"Future-trait\"><a href=\"#Future-trait\" class=\"headerlink\" title=\"Future trait\"></a>Future trait</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Future</span></span> &#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span>;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Error</span></span>;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; Poll&lt;Self::Item, Self::Error&gt;;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">wait</span></span>(slef) -&gt; <span class=\"hljs-built_in\">Result</span>::<span class=\"hljs-built_in\">Result</span>&lt;Self::Item, Self::Error&gt; &#123;<br>        ...<br>    &#125;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从代码中可以看到他有两个类型Item和Error,Item就是Future结束时返回值的类型。最主要的是poll方法，使用者需要实现方法复写自己的逻辑，Future通过poll不断的查询返回结果。</p>\n<ol>\n<li>  poll方法</li>\n</ol>\n<pre><code>尝试获取结果，没有获取值是返回Ok(Async::NotReady),有返回值是返回Ok(Async::Ready(Item)),错误时返回Result::Error(err)。该函数不会阻塞当前线程。\n</code></pre>\n<ol start=\"2\">\n<li>wait方法<br> 该方法在任务完成前会阻塞当前线程，所以它不适合在event loops场景中调用。从源码分析得出的wait方法执行流程：</li>\n</ol>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coq\">graph TD<br>    A[wait] --&gt; B(Spawn::wait_future)<br>    B--&gt;C[Spawn::poll_future_notify]<br>    C--&gt;D&#123;返回结果&#125;<br>    D--&gt;|<span class=\"hljs-type\">Ready</span>| <span class=\"hljs-type\">D1</span>(<span class=\"hljs-keyword\">end</span>)<br>    D--&gt;|<span class=\"hljs-type\">NotReady</span>| <span class=\"hljs-type\">D2</span>[Notify.park]<br>    D2--&gt;|<span class=\"hljs-type\">外部调用notify</span>| <span class=\"hljs-type\">C</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/std/mod.rs.html#227-237\">wait源码</a>  <a href=\"https://docs.rs/crate/futures/0.1.25/source/src/task_impl/core.rs\">相关代码</a></p>\n<ol start=\"3\">\n<li>Future的转换方法<br> Future有许多的转换方法，功能都类似转换完后都会把自己消费掉，生成一个新的Future。<ul>\n<li>map</li>\n<li>map_err</li>\n<li>from_err</li>\n<li>then</li>\n<li>and_then</li>\n<li>or_else</li>\n<li>join</li>\n<li>select</li>\n<li>select2</li>\n<li>into_stream  转换成Stream</li>\n<li>flattern</li>\n<li>flatten_stream 转换成Stream</li>\n<li>fuse 完成状态后不可用的一种Future</li>\n<li>insepect 完成后会调用一个结果处理函数</li>\n<li>catch_unwind</li>\n<li>shared  多线程共享的</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Future的五种生成方式\"><a href=\"#Future的五种生成方式\" class=\"headerlink\" title=\"Future的五种生成方式\"></a>Future的五种生成方式</h3><ul>\n<li>impl <a href=\"https://docs.rs/futures/0.1.25/futures/future/trait.IntoFuture.html\">IntoFuture</a> trait，通过into_future 方法生成Future, Reuslt,(A:IntoFuture,B,C…)与实现了Future的struct默认实现了IntoFuture trait。</li>\n<li>impl <a href=\"https://docs.rs/futures/0.1.25/futures/future/trait.FutureFrom.html\">FutureFrom</a> trait,通过future_from方法生成Future。</li>\n<li>impl <a href=\"https://docs.rs/futures/0.1.25/futures/future/trait.Future.html\">Future</a> trait,写具体的poll方法。</li>\n<li>通过Future的转换方法生成，可转换成不同功能的Future。</li>\n<li>通过一些库自带的方法生成Future,比如，empty, lazy, loop_fn, poll_fn, select_all, select_ok, result, ok, join_all_err等。</li>\n</ul>\n<h2 id=\"Sink-trait\"><a href=\"#Sink-trait\" class=\"headerlink\" title=\"Sink trait\"></a>Sink trait</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Sink</span></span> &#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">SinkItem</span></span>;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">SinkError</span></span>;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">start_send</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, item: Self::SinkItem) -&gt; StartSend&lt;Self::SinkItem, Self::SinkError&gt;;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll_complete</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; Poll&lt;(), Self::SinkError&gt;;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">close</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; Poll&lt;(), Self::SinkError&gt; &#123;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Sink可以理解为数据消费者，从功能上来说只接收数据，当sink满时就不再接收数据了。比如Channels,Socket,Pipes等，从一定程度上来说buffer也可以算是Sink。</p>\n<h3 id=\"sink的方法\"><a href=\"#sink的方法\" class=\"headerlink\" title=\"sink的方法\"></a>sink的方法</h3><ol>\n<li> start_send   接收发送过来的数据，数据可处理时返回AsyncSink(Ready(Item)),不可时处理返回AsyncSink(NotReady)</li>\n<li> poll_complete  flush消费掉所有缓存的数据</li>\n<li> close,关闭该sink，不再处理数据，close之后不可以再调poll_complete。</li>\n<li> wait —&gt; <a href=\"https://docs.rs/futures/0.1.25/src/futures/sink/wait.rs.html#22-59\">Wait</a> 把异步的Sink转变成同步操作。</li>\n<li> with —&gt;With 处理数据时会执行一个函数</li>\n<li> with_flat_map –&gt;WithFlatMap,对每个value使用函数变成Stream,每个处理的数据为该Stream的整个值。</li>\n<li> buffer –&gt;<a href=\"https://docs.rs/futures/0.1.25/src/futures/sink/buffer.rs.html#12-18\">Buffer</a>，为sink做指定数量的缓存</li>\n<li> fanout –&gt; <a href=\"https://docs.rs/futures/0.1.25/futures/sink/struct.Fanout.html\">Fanout</a>,让两个处理速度不一样的Sink操持同步。</li>\n<li> flush  转变成一个Future,当Sink poll_complet完成时为完成状态</li>\n<li> send 转变成一个Future,发送一个value到sink中并阻塞直到sink flush完成</li>\n<li> send_all 如send,发送的是一个Stream</li>\n<li> 其他转换方法</li>\n</ol>\n<h3 id=\"Sink的生成方式\"><a href=\"#Sink的生成方式\" class=\"headerlink\" title=\"Sink的生成方式\"></a>Sink的生成方式</h3><ul>\n<li>默认实现的Sink，如Vec,Box<Sink></li>\n<li>impl Sink trait写start_send,poll_complete方法</li>\n<li>通过转换方法生成</li>\n</ul>\n<h2 id=\"stream-trait\"><a href=\"#stream-trait\" class=\"headerlink\" title=\"stream trait\"></a>stream trait</h2><p>Stream代表任何的数据源或一系列顺序事件，他的行为很像是Iterator,和Future一样他不会阻塞适合于异步编程</p>\n<h3 id=\"Stream-方法\"><a href=\"#Stream-方法\" class=\"headerlink\" title=\"Stream 方法\"></a>Stream 方法</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Stream</span></span> &#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span>;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Error</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; Poll&lt;<span class=\"hljs-built_in\">Option</span>&lt;Self::Item&gt;, Self::Error&gt;;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>poll,尝试获取下一个值，如果Stream已结束返回None</li>\n<li>wait –&gt;Wait,创建一个迭代器，会阻塞当前线程直到Stream结束</li>\n<li>一些转换方法，较特殊的如collect方法生成<a href=\"https://docs.rs/futures/0.1.25/src/futures/stream/collect.rs.html#13-16\">Collect</a>把Stream中的值收集到一个Vector中，本身是一个Future；forward也是生成一个Future。</li>\n</ol>\n<h3 id=\"Stream的生成\"><a href=\"#Stream的生成\" class=\"headerlink\" title=\"Stream的生成\"></a>Stream的生成</h3><ol>\n<li>通过<a href=\"https://docs.rs/futures/0.1.25/futures/future/struct.IntoStream.html\">IntoStream</a> trait而来</li>\n<li>impl Stream trait写poll方法</li>\n<li>通过<a href=\"https://docs.rs/futures/0.1.25/futures/stream/index.html\">以下方法</a>生成：empty,futures_ordered,futures_unordered,iter,iter_ok,iter_result,once,poll_fn,repeat,unfold</li>\n<li>通过转换方法生成</li>\n</ol>\n<h2 id=\"Executor\"><a href=\"#Executor\" class=\"headerlink\" title=\"Executor\"></a>Executor</h2><p>Future代表了一个异步结果值，但开始并没有值，如何得到结果值呢。这就需要有一个机制去驱动他，这就是Executor的作用。通过executor调用Future去执行poll方法获取相应的值。但在futures这个库中只提供了相应的trait和简单的wait,notify实现。若想看线程池方案的executor实现可查点<a href=\"https://docs.rs/tokio/0.1.15/tokio/\">tokio库</a>。</p>\n<p>Sink与Stream最终都会转化为Future在Executor中执行。</p>\n<h3 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h3><p>一个重要的概念Task,它是一个轻量级的future的执行任务。通过<a href=\"https://docs.rs/futures/0.1.25/futures/task/fn.current.html\">current</a>函数获取当前future的Task</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><br><span class=\"hljs-meta\">#[derive(Clone)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Task</span></span> &#123;<br>    id: <span class=\"hljs-built_in\">usize</span>,<br>    unpark: TaskUnpark,<br>    events: UnparkEvents,<br>&#125;<br><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">TaskUnpark</span></span> &#123;<br>    handle: NotifyHandle,<br>    id: <span class=\"hljs-built_in\">usize</span>,<br>&#125;<br><br><span class=\"hljs-keyword\">impl</span> Task&#123;<br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">notify</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">self</span>.events.notify(); -&gt; no operation<br>        <span class=\"hljs-keyword\">self</span>.unpark.notify();-&gt;handle.notify(id)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"AtomicTask\"><a href=\"#AtomicTask\" class=\"headerlink\" title=\"AtomicTask\"></a><a href=\"https://docs.rs/futures/0.1.25/futures/task/struct.AtomicTask.html\">AtomicTask</a></h3><p>它的作用是作任务通知，当计算任务完成时通知代表其异步结果的Future。再这之前必须调用register注册Future的task，每个AtomicTask只能注册一个任务。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">AtomicTask</span></span> &#123;<br>    state: AtomicUsize,<br>    task: UnsafeCell&lt;<span class=\"hljs-built_in\">Option</span>&lt;Task&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Notify\"><a href=\"#Notify\" class=\"headerlink\" title=\"Notify\"></a>Notify</h3><p>   Noitfy是一个trait,用于通知executor执行future的poll方法。内部默认使用的<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/std/mod.rs.html#227-237\">ThreadNotify</a>实现。<br>   NotifyHandle是Notify的句柄，通过NotifyHandle可以在其他地方调用Notify的notify方法。</p>\n<h3 id=\"LocalKey\"><a href=\"#LocalKey\" class=\"headerlink\" title=\"LocalKey\"></a>LocalKey</h3><p>代表Task的本地变量，可通过<a href=\"https://docs.rs/futures/0.1.25/futures/macro.task_local.html\">task_local</a>生成</p>\n<h3 id=\"future的Wait代码分析\"><a href=\"#future的Wait代码分析\" class=\"headerlink\" title=\"future的Wait代码分析\"></a>future的Wait代码分析</h3><ol>\n<li>找到future的<a href=\"https://docs.rs/futures/0.1.25/src/futures/future/mod.rs.html#295-300\">wait</a>入口，内部调用了 <blockquote>\n<p>::executor::spawn(self).wait_future()</p>\n</blockquote>\n</li>\n<li>找到<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/mod.rs.html#254-260\">spawn</a>,里面生成了一个Spawn实例。<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">spawn</span></span>&lt;T&gt;(obj: T) -&gt; Spawn&lt;T&gt; &#123;<br>        Spawn &#123;<br>        id: fresh_task_id(),<br>        obj: obj,<br>        data: local_map(),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>找到Spawn的<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/std/mod.rs.html#227-237\">wait_future</a>方法:<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">wait_future</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;F::Item, F::Error&gt; &#123;<br>        ThreadNotify::with_current(|notify| &#123;<br><br>            <span class=\"hljs-keyword\">loop</span> &#123;<br>                <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span>.poll_future_notify(notify, <span class=\"hljs-number\">0</span>)? &#123;<br>                    Async::NotReady =&gt; notify.park(),<br>                    Async::Ready(e) =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Ok</span>(e),<br>                &#125;<br>            &#125;<br>        &#125;)<br>    &#125;<br><br></code></pre></td></tr></table></figure>\n往下找到475行<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\">thread_local! &#123;<br>    <span class=\"hljs-keyword\">static</span> CURRENT_THREAD_NOTIFY: Arc&lt;ThreadNotify&gt; = Arc::new(ThreadNotify &#123;<br>        state: AtomicUsize::new(IDLE),<br>        mutex: Mutex::new(()),<br>        condvar: Condvar::new(),<br>    &#125;);<br>&#125;<br>.....<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_current</span></span>&lt;F, R&gt;(f: F) -&gt; R<br>        <span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;Arc&lt;ThreadNotify&gt;) -&gt; R,<br>    &#123;<br>        CURRENT_THREAD_NOTIFY.with(|notify| f(notify))<br>    &#125;<br></code></pre></td></tr></table></figure>\n相当于直接调用了一个loop循环，内部调用了poll_future_notify方法，如果返回NotReady则调用<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/std/mod.rs.html#481-516\">park</a>,阻塞了当前线程：<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">fn park(&amp;<span class=\"hljs-built_in\">self</span>) &#123;<br>        <span class=\"hljs-params\">...</span>.<br>        <br>        <span class=\"hljs-keyword\">let</span> mut m = <span class=\"hljs-built_in\">self</span>.mutex.lock().unwrap();<br><br>     <span class=\"hljs-params\">...</span><span class=\"hljs-params\">...</span><br>        <span class=\"hljs-keyword\">loop</span> &#123;<br>            m = <span class=\"hljs-built_in\">self</span>.condvar.wait(m).unwrap();<br><br>     <span class=\"hljs-params\">...</span>..<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n进入<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/mod.rs.html#320-327\">poll_future_notify</a>方法:<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll_future_notify</span></span>&lt;N&gt;(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>,<br>                                notify: &amp;N,<br>                                id: <span class=\"hljs-built_in\">usize</span>) -&gt; Poll&lt;T::Item, T::Error&gt;<br>       <span class=\"hljs-keyword\">where</span> N: <span class=\"hljs-built_in\">Clone</span> + <span class=\"hljs-built_in\">Into</span>&lt;NotifyHandle&gt;,<br>             T: Future,<br>   &#123;<br>       <span class=\"hljs-keyword\">self</span>.poll_fn_notify(notify, id, |f| f.poll())<br>   &#125;<br></code></pre></td></tr></table></figure>\n进入poll_fn_notify</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll_fn_notify</span></span>&lt;N, F, R&gt;(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>,<br>                             notify: &amp;N,<br>                             id: <span class=\"hljs-built_in\">usize</span>,<br>                             f: F) -&gt; R<br>        <span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> T) -&gt; R,<br>              N: <span class=\"hljs-built_in\">Clone</span> + <span class=\"hljs-built_in\">Into</span>&lt;NotifyHandle&gt;,<br>    &#123;<br>        <span class=\"hljs-keyword\">let</span> mk = || notify.clone().into();<br>        <span class=\"hljs-keyword\">self</span>.enter(BorrowedUnpark::new(&amp;mk, id), f)<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>进入enter方法</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">enter</span></span>&lt;F, R&gt;(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, unpark: BorrowedUnpark, f: F) -&gt; R<br>        <span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> T) -&gt; R<br>    &#123;<br>        <span class=\"hljs-keyword\">let</span> borrowed = BorrowedTask &#123;<br>            id: <span class=\"hljs-keyword\">self</span>.id,<br>            unpark: unpark,<br>            events: BorrowedEvents::new(),<br>            map: &amp;<span class=\"hljs-keyword\">self</span>.data,<br>        &#125;;<br>        <span class=\"hljs-keyword\">let</span> obj = &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.obj;<br>        set(&amp;borrowed, || f(obj))<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>进入<a href=\"https://docs.rs/crate/futures/0.1.25/source/src/task_impl/core.rs\">set</a>方法</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">set</span></span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>, F, R&gt;(task: &amp;BorrowedTask&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt;, f: F) -&gt; R<br>    <span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>() -&gt; R<br>&#123;<br>    <span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">match</span> SET.load(Relaxed) &#123;<br>        <span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">&quot;not initialized&quot;</span>),<br>        n =&gt; <span class=\"hljs-keyword\">unsafe</span> &#123; mem::transmute::&lt;<span class=\"hljs-built_in\">usize</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(*<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>)&gt;(n) &#125;,<br>    &#125;;<br><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reset</span></span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(*<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>), *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>);<br><br>    <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Reset &#123;<br>        <span class=\"hljs-meta\">#[inline]</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) &#123;<br>            (<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>)(<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">let</span> _reset = Reset(set, get_ptr().unwrap());<br>    set(task <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _ <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>);<br>    f()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>简单调用了这个闭包，即future.poll()方法。</p>\n<p>到这里poll方法如果成功返回则就结束了，如果返回NotReady则阻塞住了，<em><strong>如何通知unpark呢？</strong></em></p>\n<p>我们注意到上面有个<a href=\"https://docs.rs/crate/futures/0.1.25/source/src/task_impl/core.rs\">BorrowedTask</a>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Copy, Clone)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">BorrowedUnpark</span></span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; &#123;<br>    f: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-built_in\">Fn</span>() -&gt; NotifyHandle,<br>    id: <span class=\"hljs-built_in\">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>有一个返回<a href=\"https://docs.rs/futures/0.1/src/futures/task_impl/mod.rs.html#630-632\">NotifyHandle</a>的变量，下面就用到了他进行通知unpark</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; BorrowedUnpark&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; &#123;<br>    <span class=\"hljs-meta\">#[inline]</span><br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(f: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-built_in\">Fn</span>() -&gt; NotifyHandle, id: <span class=\"hljs-built_in\">usize</span>) -&gt; BorrowedUnpark&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; &#123;<br>        BorrowedUnpark &#123; f: f, id: id &#125;<br>    &#125;<br><br>    <span class=\"hljs-meta\">#[inline]</span><br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">to_owned</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; TaskUnpark &#123;<br>        <span class=\"hljs-keyword\">let</span> handle = (<span class=\"hljs-keyword\">self</span>.f)();<br>        <span class=\"hljs-keyword\">let</span> id = handle.clone_id(<span class=\"hljs-keyword\">self</span>.id);<br>        TaskUnpark &#123; handle: handle, id: id &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">impl</span> TaskUnpark &#123;<br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">notify</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">self</span>.handle.notify(<span class=\"hljs-keyword\">self</span>.id);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">will_notify</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;BorrowedUnpark) -&gt; <span class=\"hljs-built_in\">bool</span> &#123;<br>        <span class=\"hljs-keyword\">self</span>.id == other.id &amp;&amp; <span class=\"hljs-keyword\">self</span>.handle.inner == (other.f)().inner<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>所以要想通知到他就需要拿到这个task。</p>\n<h2 id=\"sync-模块\"><a href=\"#sync-模块\" class=\"headerlink\" title=\"sync 模块\"></a>sync 模块</h2><p>这个模块主要是处理future,streams和sinks使用时的同步工具，与标准库不同他不会阻塞线程，是工作在task级别。</p>\n<h3 id=\"mpsc\"><a href=\"#mpsc\" class=\"headerlink\" title=\"mpsc\"></a>mpsc</h3><p> multi-producer,single-consumer模型，FIFO queue with back pressure。主要有Sender和Receiver两个角色，通过他们很好的处理了backPressure的问题。</p>\n<h3 id=\"Sender-and-Receiver\"><a href=\"#Sender-and-Receiver\" class=\"headerlink\" title=\"Sender and Receiver\"></a>Sender and Receiver</h3><p>本质上Sender是一个Sink,Receiver是一个Stream。可通过<a href=\"https://docs.rs/futures/0.1.25/futures/sync/mpsc/fn.channel.html\">channel</a>方法生成</p>\n<h4 id=\"source-code\"><a href=\"#source-code\" class=\"headerlink\" title=\"source code\"></a><a href=\"https://docs.rs/futures/0.1.25/src/futures/sync/mpsc/mod.rs.html#639-670\">source code</a></h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Sender</span></span>&lt;T&gt; &#123;<br>    <span class=\"hljs-comment\">// Channel state shared between the sender and receiver.</span><br>    inner: Arc&lt;Inner&lt;T&gt;&gt;,<br><br>    <span class=\"hljs-comment\">// Handle to the task that is blocked on this sender. This handle is sent</span><br>    <span class=\"hljs-comment\">// to the receiver half in order to be notified when the sender becomes</span><br>    <span class=\"hljs-comment\">// unblocked.</span><br>    sender_task: Arc&lt;Mutex&lt;SenderTask&gt;&gt;,<br><br>    <span class=\"hljs-comment\">// True if the sender might be blocked. This is an optimization to avoid</span><br>    <span class=\"hljs-comment\">// having to lock the mutex most of the time.</span><br>    maybe_parked: <span class=\"hljs-built_in\">bool</span>,<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Receiver</span></span>&lt;T&gt; &#123;<br>    inner: Arc&lt;Inner&lt;T&gt;&gt;,<br>&#125;<br><br><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inner</span></span>&lt;T&gt; &#123;<br>    <span class=\"hljs-comment\">// Max buffer size of the channel. If `None` then the channel is unbounded.</span><br>    buffer: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">usize</span>&gt;,<br><br>    <span class=\"hljs-comment\">// Internal channel state. Consists of the number of messages stored in the</span><br>    <span class=\"hljs-comment\">// channel as well as a flag signalling that the channel is closed.</span><br>    state: AtomicUsize,<br><br>    <span class=\"hljs-comment\">// Atomic, FIFO queue used to send messages to the receiver</span><br>    message_queue: Queue&lt;<span class=\"hljs-built_in\">Option</span>&lt;T&gt;&gt;,<br><br>    <span class=\"hljs-comment\">// Atomic, FIFO queue used to send parked task handles to the receiver.</span><br>    parked_queue: Queue&lt;Arc&lt;Mutex&lt;SenderTask&gt;&gt;&gt;,<br><br>    <span class=\"hljs-comment\">// Number of senders in existence</span><br>    num_senders: AtomicUsize,<br><br>    <span class=\"hljs-comment\">// Handle to the receiver&#x27;s task.</span><br>    recv_task: Mutex&lt;ReceiverTask&gt;,<br>&#125;<br><br><br></code></pre></td></tr></table></figure>\n<p>可以看出Sender与Receiver共享了Inner部分，inner中有两个队列，一个用于存储消息，一个用于存储阻塞的发送任务。</p>\n<h4 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h4><pre><code>The steps for sending a message are roughly:\n\n1. Increment the channel message count\n2. If the channel is at capacity, push the task handle onto the wait queue\n3. Push the message onto the message queue.\n\nThe steps for receiving a message are roughly:\n\n1. Pop a message from the message queue\n2. Pop a task handle from the wait queue\n3. Decrement the channel message count.\n</code></pre>\n<p>分析代码时可以以<a href=\"https://docs.rs/futures/0.1.25/src/futures/sync/mpsc/mod.rs.html#923-958\">Receiver的Stream trait中的poll方法</a>为入口，或者以  <a href=\"https://docs.rs/futures/0.1.25/src/futures/sync/mpsc/mod.rs.html#643-654\">Sender的Sink trait中的start_send方法</a>为入口</p>\n<h3 id=\"SpawnHandle\"><a href=\"#SpawnHandle\" class=\"headerlink\" title=\"SpawnHandle\"></a><a href=\"https://docs.rs/futures/0.1.25/futures/sync/mpsc/struct.SpawnHandle.html\">SpawnHandle</a></h3><p> 通过<a href=\"https://docs.rs/futures/0.1.25/futures/sync/mpsc/fn.spawn.html\">spawn 方法</a>可产生一个SpawnHandle，<br> 参数<a href=\"https://docs.rs/futures/0.1.25/futures/future/trait.Executor.html\">executor</a>为上面提到过的Executor没有具体实现。<br> SpawnHandle是一个Stream的代理,当被drop时，Stream就不再产生数据了</p>\n<h3 id=\"onshot\"><a href=\"#onshot\" class=\"headerlink\" title=\"onshot\"></a>onshot</h3><p> 与mpsc关不多，也分为Sender和Receiver两个角色。但是Sender和Receiver本质是一个Future。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-02-cell/",
            "url": "http://example.com/2018-11-02-cell/",
            "title": "rust cell 详解",
            "date_published": "2018-11-02T14:39:42.000Z",
            "content_html": "<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p><a href=\"https://doc.rust-lang.org/std/cell/index.html\">https://doc.rust-lang.org/std/cell/index.html</a></p>\n<p>众所周知，rust的内存安全是基于一个规则，一个对像须满足以下规则：</p>\n<ul>\n<li>只存在一个可变引用</li>\n<li>有多个不可变引用</li>\n</ul>\n<p>在写rust代码时，会发现这样的规则在写代码时会受到一定的束缚。于是rust官方出了一个可以灵活解决对像可变性问题的工具cell。</p>\n<h2 id=\"cell与Mutex等的不同\"><a href=\"#cell与Mutex等的不同\" class=\"headerlink\" title=\"cell与Mutex等的不同\"></a>cell与Mutex等的不同</h2><p>诚然我们可以用Mutex, atomic等来解决可变性问题，但cell与mutex有本质的不同。<br>cell是线程安全的（没有实现Sync，不能跨线程访问），Mutex主要用来解决多线程数据竞争的。</p>\n<h2 id=\"cell的具体分析\"><a href=\"#cell的具体分析\" class=\"headerlink\" title=\"cell的具体分析\"></a>cell的具体分析</h2><p>cell的实现分Cell, RefCell, UnsafeCell，还有一个开源实现LazyCell</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[repr(transparent)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Cell</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; &#123;<br>    value: UnsafeCell&lt;T&gt;,<br>&#125;<br><br><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RefCell</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; &#123;<br>    borrow: Cell&lt;BorrowFlag&gt;,<br>    value: UnsafeCell&lt;T&gt;,<br>&#125;<br><br><br><span class=\"hljs-meta\">#[repr(transparent)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">UnsafeCell</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; &#123;<br>    value: T,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>从源码上来看Cell和RefCell的内部都是由UnsafeCell来实现的, 要想理解Cell与RefCell就需要先了解UnsafeCell</p>\n<h3 id=\"UnsafeCell\"><a href=\"#UnsafeCell\" class=\"headerlink\" title=\"UnsafeCell\"></a>UnsafeCell</h3><p>UnsafeCell非常简单，有一个重要的方法：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-comment\">//返回一个可变指针</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; *<span class=\"hljs-keyword\">mut</span> T &#123;<br>        <span class=\"hljs-keyword\">self</span> <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> UnsafeCell&lt;T&gt; <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> T <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> T<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>通过一个不可变对像返回一个可变的对像指针，Cell与RefCell正是利用了这个达到相应的目的，前提是他们是线程安全的。</p>\n<h3 id=\"Cell\"><a href=\"#Cell\" class=\"headerlink\" title=\"Cell\"></a>Cell</h3><p>看一下replace,get, set, take等方法，都是基于UnsafeCell返回的可变指针的内存操作</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">replace</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, val: T) -&gt; T &#123;<br>        <span class=\"hljs-comment\">// SAFETY: This can cause data races if called from a separate thread,</span><br>        <span class=\"hljs-comment\">// but `Cell` is `!Sync` so this won&#x27;t happen.</span><br>        mem::replace(<span class=\"hljs-keyword\">unsafe</span> &#123; &amp;<span class=\"hljs-keyword\">mut</span> *<span class=\"hljs-keyword\">self</span>.value.get() &#125;, val)<br>    &#125;<br><span class=\"hljs-comment\">//T: Copy    </span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; T &#123;<br>        <span class=\"hljs-comment\">// SAFETY: This can cause data races if called from a separate thread,</span><br>        <span class=\"hljs-comment\">// but `Cell` is `!Sync` so this won&#x27;t happen.</span><br>        <span class=\"hljs-keyword\">unsafe</span> &#123; *<span class=\"hljs-keyword\">self</span>.value.get() &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"RefCell\"><a href=\"#RefCell\" class=\"headerlink\" title=\"RefCell\"></a>RefCell</h3><p>Refcell是在Cell的增强版，他在Cell的基础上添加了借用，内部维护着一个借用的标识，在运行时做借用检查。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">borrow</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; Ref&lt;<span class=\"hljs-symbol\">&#x27;_</span>, T&gt; &#123;<br>        <span class=\"hljs-keyword\">self</span>.try_borrow().expect(<span class=\"hljs-string\">&quot;already mutably borrowed&quot;</span>)<br>    &#125;<br>    <br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">borrow_mut</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; RefMut&lt;<span class=\"hljs-symbol\">&#x27;_</span>, T&gt; &#123;<br>        <span class=\"hljs-keyword\">self</span>.try_borrow_mut().expect(<span class=\"hljs-string\">&quot;already borrowed&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>主要方法borrow和borrow_mut返回相应的引用对像，当Ref或RefMut销毁时相应的借用关系消除</p>\n<h3 id=\"LazyCell\"><a href=\"#LazyCell\" class=\"headerlink\" title=\"LazyCell\"></a>LazyCell</h3><p><a href=\"https://github.com/indiv0/lazycell\">https://github.com/indiv0/lazycell</a>, 从代码看其和Cell功能类似，用于延迟初始化。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">LazyCell</span></span>&lt;T&gt; &#123;<br>    inner: UnsafeCell&lt;<span class=\"hljs-built_in\">Option</span>&lt;T&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n",
            "tags": []
        }
    ]
}
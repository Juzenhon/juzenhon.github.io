{
    "version": "https://jsonfeed.org/version/1",
    "title": "黑色红桃7 • All posts by \"rust\" category",
    "description": "朱新宏的博客",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2018-11-20-rust-static/",
            "url": "http://example.com/2018-11-20-rust-static/",
            "title": "rust static详解",
            "date_published": "2018-11-20T12:46:11.000Z",
            "content_html": "<h3 id=\"static-语法\"><a href=\"#static-语法\" class=\"headerlink\" title=\"static 语法\"></a>static 语法</h3><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">static mut? IDENTIFER: <span class=\"hljs-keyword\">Type</span> <span class=\"hljs-type\">(= </span>Expresssion)?;<br></code></pre></td></tr></table></figure>\n<p>其中mut可有可无，Expresssion为表达式，可以没有。</p>\n<h3 id=\"static与常量有区别\"><a href=\"#static与常量有区别\" class=\"headerlink\" title=\"static与常量有区别\"></a>static与常量有区别</h3><ul>\n<li>static有自己的内存地址，其生命周期是‘static的，常量没有</li>\n<li>所有的对static item的引用指向同一个地址，而每个常量都有自己的地址</li>\n<li>static的类型必须是Sync的，跨线程访问</li>\n</ul>\n<h3 id=\"mut-static\"><a href=\"#mut-static\" class=\"headerlink\" title=\"mut static\"></a>mut static</h3><p>如果一个static item是mut的，并发访问时可能会有问题，所以对他的引用是unsafe的。我们要自己确保他的正确性。</p>\n<h3 id=\"static-变量\"><a href=\"#static-变量\" class=\"headerlink\" title=\"static 变量\"></a>static 变量</h3><p>按照static的语法定义变量时经常遇到这样的错误:</p>\n<blockquote>\n<p>calls in statics are limited to constant functions, tuple structs and tuple variants</p>\n</blockquote>\n<p>也就是说上面的Expresssion只是条件的。只能是常量函数，tuple结构等。而不能像Java语言一样 static Object STATIC_OBJ = new Object();</p>\n<p>其中主要的区别在于是static的初始化必须是在编译期可确定的。也就是说其内存大小是在编译期确定的，而Java是在运行时。</p>\n<h3 id=\"lazy-static\"><a href=\"#lazy-static\" class=\"headerlink\" title=\"lazy_static\"></a>lazy_static</h3><p>由于rust static在编译期确定大小的特性，一些rust程序员在编写代码时产生了诸多不便，就有了<a href=\"https://github.com/rust-lang-nursery/lazy-static.rs\">lazy_static</a>这个库。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\">lazy_static! &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">ref</span> HASHMAP: HashMap&lt;<span class=\"hljs-built_in\">u32</span>, &amp;<span class=\"hljs-symbol\">&#x27;static</span> <span class=\"hljs-built_in\">str</span>&gt; = &#123;<br>        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> m = HashMap::new();<br>        m.insert(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>);<br>        m.insert(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>);<br>        m.insert(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;baz&quot;</span>);<br>        m<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>lazy_static是第一次使用时调用初始化，相当于把初始化挪到了运行时。</p>\n<h3 id=\"lazy-mut\"><a href=\"#lazy-mut\" class=\"headerlink\" title=\"lazy_mut\"></a>lazy_mut</h3><p><a href=\"https://docs.rs/lazy_mut/0.1.0/lazy_mut/\">lazy_mut</a>是用来解决变量延迟初始化的, 也包括static mut。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-02-cell/",
            "url": "http://example.com/2018-11-02-cell/",
            "title": "rust cell 详解",
            "date_published": "2018-11-02T14:39:42.000Z",
            "content_html": "<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p><a href=\"https://doc.rust-lang.org/std/cell/index.html\">https://doc.rust-lang.org/std/cell/index.html</a></p>\n<p>众所周知，rust的内存安全是基于一个规则，一个对像须满足以下规则：</p>\n<ul>\n<li>只存在一个可变引用</li>\n<li>有多个不可变引用</li>\n</ul>\n<p>在写rust代码时，会发现这样的规则在写代码时会受到一定的束缚。于是rust官方出了一个可以灵活解决对像可变性问题的工具cell。</p>\n<h2 id=\"cell与Mutex等的不同\"><a href=\"#cell与Mutex等的不同\" class=\"headerlink\" title=\"cell与Mutex等的不同\"></a>cell与Mutex等的不同</h2><p>诚然我们可以用Mutex, atomic等来解决可变性问题，但cell与mutex有本质的不同。<br>cell是线程安全的（没有实现Sync，不能跨线程访问），Mutex主要用来解决多线程数据竞争的。</p>\n<h2 id=\"cell的具体分析\"><a href=\"#cell的具体分析\" class=\"headerlink\" title=\"cell的具体分析\"></a>cell的具体分析</h2><p>cell的实现分Cell, RefCell, UnsafeCell，还有一个开源实现LazyCell</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[repr(transparent)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Cell</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; &#123;<br>    value: UnsafeCell&lt;T&gt;,<br>&#125;<br><br><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RefCell</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; &#123;<br>    borrow: Cell&lt;BorrowFlag&gt;,<br>    value: UnsafeCell&lt;T&gt;,<br>&#125;<br><br><br><span class=\"hljs-meta\">#[repr(transparent)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">UnsafeCell</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; &#123;<br>    value: T,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>从源码上来看Cell和RefCell的内部都是由UnsafeCell来实现的, 要想理解Cell与RefCell就需要先了解UnsafeCell</p>\n<h3 id=\"UnsafeCell\"><a href=\"#UnsafeCell\" class=\"headerlink\" title=\"UnsafeCell\"></a>UnsafeCell</h3><p>UnsafeCell非常简单，有一个重要的方法：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-comment\">//返回一个可变指针</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; *<span class=\"hljs-keyword\">mut</span> T &#123;<br>        <span class=\"hljs-keyword\">self</span> <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> UnsafeCell&lt;T&gt; <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> T <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> T<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>通过一个不可变对像返回一个可变的对像指针，Cell与RefCell正是利用了这个达到相应的目的，前提是他们是线程安全的。</p>\n<h3 id=\"Cell\"><a href=\"#Cell\" class=\"headerlink\" title=\"Cell\"></a>Cell</h3><p>看一下replace,get, set, take等方法，都是基于UnsafeCell返回的可变指针的内存操作</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">replace</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, val: T) -&gt; T &#123;<br>        <span class=\"hljs-comment\">// SAFETY: This can cause data races if called from a separate thread,</span><br>        <span class=\"hljs-comment\">// but `Cell` is `!Sync` so this won&#x27;t happen.</span><br>        mem::replace(<span class=\"hljs-keyword\">unsafe</span> &#123; &amp;<span class=\"hljs-keyword\">mut</span> *<span class=\"hljs-keyword\">self</span>.value.get() &#125;, val)<br>    &#125;<br><span class=\"hljs-comment\">//T: Copy    </span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; T &#123;<br>        <span class=\"hljs-comment\">// SAFETY: This can cause data races if called from a separate thread,</span><br>        <span class=\"hljs-comment\">// but `Cell` is `!Sync` so this won&#x27;t happen.</span><br>        <span class=\"hljs-keyword\">unsafe</span> &#123; *<span class=\"hljs-keyword\">self</span>.value.get() &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"RefCell\"><a href=\"#RefCell\" class=\"headerlink\" title=\"RefCell\"></a>RefCell</h3><p>Refcell是在Cell的增强版，他在Cell的基础上添加了借用，内部维护着一个借用的标识，在运行时做借用检查。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">borrow</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; Ref&lt;<span class=\"hljs-symbol\">&#x27;_</span>, T&gt; &#123;<br>        <span class=\"hljs-keyword\">self</span>.try_borrow().expect(<span class=\"hljs-string\">&quot;already mutably borrowed&quot;</span>)<br>    &#125;<br>    <br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">borrow_mut</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; RefMut&lt;<span class=\"hljs-symbol\">&#x27;_</span>, T&gt; &#123;<br>        <span class=\"hljs-keyword\">self</span>.try_borrow_mut().expect(<span class=\"hljs-string\">&quot;already borrowed&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>主要方法borrow和borrow_mut返回相应的引用对像，当Ref或RefMut销毁时相应的借用关系消除</p>\n<h3 id=\"LazyCell\"><a href=\"#LazyCell\" class=\"headerlink\" title=\"LazyCell\"></a>LazyCell</h3><p><a href=\"https://github.com/indiv0/lazycell\">https://github.com/indiv0/lazycell</a>, 从代码看其和Cell功能类似，用于延迟初始化。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">LazyCell</span></span>&lt;T&gt; &#123;<br>    inner: UnsafeCell&lt;<span class=\"hljs-built_in\">Option</span>&lt;T&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n",
            "tags": []
        }
    ]
}
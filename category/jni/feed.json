{
    "version": "https://jsonfeed.org/version/1",
    "title": "黑色红桃7 • All posts by \"jni\" category",
    "description": "朱新宏的博客",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2018-01-11-jnr/",
            "url": "http://example.com/2018-01-11-jnr/",
            "title": "jni与jnr",
            "date_published": "2018-01-11T13:48:26.000Z",
            "content_html": "<h3 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h3><p>在熟悉了JNI使用及其原理后，发现在JNI有一些缺点：</p>\n<ul>\n<li>对新手不够友好，上手成本相当的高</li>\n<li>需要熟悉c/c++等native语言</li>\n<li>对接过程比较复杂</li>\n</ul>\n<p>对于熟悉JNI的工程师来说，可以驾轻就熟的写出如下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JNITest</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>       <span class=\"hljs-keyword\">try</span> &#123;<br>            System.loadLibrary(<span class=\"hljs-string\">&quot;libXXX&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">catch</span>(Exception e) &#123;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">native</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br><br><span class=\"hljs-function\">JNIEXPORT jstring <span class=\"hljs-title\">Java_JNITest_test</span><span class=\"hljs-params\">(JNIEnv*, jclass)</span></span>;<br></code></pre></td></tr></table></figure>\n<p>写惯了这样的对接代码后发现一个问题: java代码与jni native接口似乎是可以自动映射的，包括参数，函数名。如果在jni胶水层不需要写其他逻辑代码的话，就是一个简单的本地调用再封装。</p>\n<p>这些千篇一律的代码，可不可以标准化呢？有两种比较好的解决方案:</p>\n<ul>\n<li><a href=\"https://github.com/java-native-access/jna\">JNA(Java Native Access)</a></li>\n<li><a href=\"https://github.com/jnr\">JNR(Java Native Runtime)</a></li>\n</ul>\n<p><a href=\"https://www.oracle.com/technetwork/java/jvmls2013nutter-2013526.pdf\">这篇文章</a>很好的讲述了他们的之间的区别，不过文章比较老了，随着时间的流逝，技术在不断的更新升级。成熟的方案意是会受到用户的青睐。</p>\n<h3 id=\"JNA-JNR\"><a href=\"#JNA-JNR\" class=\"headerlink\" title=\"JNA/JNR\"></a>JNA/JNR</h3><p>这两种解决方案都不需要写jni代码，集成起来相当的方便</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JNATest</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CLibrary</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">Library</span> &#123;<br>        CLibrary INSTANCE = (CLibrary)Native.loadLibrary(<span class=\"hljs-string\">&quot;CDLL&quot;</span>, CLibrary.<span class=\"hljs-keyword\">class</span>);<br><br>        <span class=\"hljs-function\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> a, <span class=\"hljs-built_in\">int</span> b</span>)</span>;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>)</span> &#123;<br>        <span class=\"hljs-built_in\">int</span> sum = CLibrary.INSTANCE.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>);<br><br>        System.<span class=\"hljs-keyword\">out</span>.println(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><ul>\n<li>类型映射</li>\n<li>JNI Stub</li>\n<li><a href=\"https://asm.ow2.io/\">字节码生成</a></li>\n</ul>\n<h3 id=\"与JNI的区别\"><a href=\"#与JNI的区别\" class=\"headerlink\" title=\"与JNI的区别\"></a>与JNI的区别</h3><ul>\n<li>JNI是JNA/JNR的基础</li>\n<li>JNA/JNR不可能取代JNI， 适用于Java调用native的场景</li>\n<li>native调用java代码，还是要借用jni,自己写代码</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2017-08-17-jni/",
            "url": "http://example.com/2017-08-17-jni/",
            "title": "jni实践总结",
            "date_published": "2017-08-17T11:45:53.000Z",
            "content_html": "<h3 id=\"JNI介绍\"><a href=\"#JNI介绍\" class=\"headerlink\" title=\"JNI介绍\"></a>JNI介绍</h3><p>JNI (java native interface), 是java与native语言(c/c++, rust等)之间的胶水， 用于解决java与native之间相互调用的问题。</p>\n<h3 id=\"JNI-Function与指针\"><a href=\"#JNI-Function与指针\" class=\"headerlink\" title=\"JNI Function与指针\"></a>JNI Function与指针</h3><p>native代码在访问JVM相关的信息时所使用的函数叫JNI函数。JNI函数只能通过JNI指针调用。</p>\n<p><img src=\"https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/images/designa.gif\" alt=\"image\"></p>\n<p>JNI接口的组织形式和C++的函数表非常相似。这样设计的主要优势是JNI的名字空间可以与native分开。JVM可以很容易的保有多个版本的JNI函数表。</p>\n<p>注意JNIEnv是线程本地变量，不可跨线程使用</p>\n<h3 id=\"加载动态库与方法映射\"><a href=\"#加载动态库与方法映射\" class=\"headerlink\" title=\"加载动态库与方法映射\"></a>加载动态库与方法映射</h3><p>java加载动态库</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.juzenhon.jni;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>        System.loadLibrary(“libXXX”);<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">native</span> staic <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>)</span></span>;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">native</span> String <span class=\"hljs-title\">getStr</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>jni层想关方法</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//加载动动态库时回调</span><br>JNIEXPORT jint JNICALL <span class=\"hljs-constructor\">JNI_OnLoad(JavaVM <span class=\"hljs-operator\">*</span><span class=\"hljs-params\">vm</span>, <span class=\"hljs-params\">void</span> <span class=\"hljs-operator\">*</span><span class=\"hljs-params\">reserved</span>)</span>;<br><span class=\"hljs-comment\">//卸载动态库时回调</span><br>JNIEXPORT void JNICALL <span class=\"hljs-constructor\">JNI_OnUnload(JavaVM <span class=\"hljs-operator\">*</span><span class=\"hljs-params\">vm</span>, <span class=\"hljs-params\">void</span> <span class=\"hljs-operator\">*</span><span class=\"hljs-params\">reserved</span>)</span>;<br><br><span class=\"hljs-comment\">//add方法在jni中的映射</span><br>JNIEXPORT jint <span class=\"hljs-constructor\">Java_com_juzenhon_jni_Test_add(JNIEnv<span class=\"hljs-operator\">*</span>, <span class=\"hljs-params\">jclass</span>, <span class=\"hljs-params\">jint</span>, <span class=\"hljs-params\">jint</span>)</span>;<br><br><span class=\"hljs-comment\">//getStr方法在jni中的映射</span><br>JNIEXPORT jstring <span class=\"hljs-constructor\">Java_com_juzenhon_jni_Test_getStr(JNIEnv<span class=\"hljs-operator\">*</span>, <span class=\"hljs-params\">jobject</span>)</span>;<br><br><span class=\"hljs-comment\">//除了上面这种通过Java_包名_类名_方法名的映射形式，还可以通过该函数注册本地方法关联映射</span><br><span class=\"hljs-constructor\">RegisterNatives()</span> <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"native方法参数-jni类型\"><a href=\"#native方法参数-jni类型\" class=\"headerlink\" title=\"native方法参数, jni类型\"></a>native方法参数, jni类型</h3><p>所有java native的第一个参数是JNI接口指针(也就是JNIEnv), 第二个参数依赖于该native方法是否是静态的，非静态的是object的引用 （jobject), 静态的是jclass。其余的是相对应的java参数(对应关系可以在<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/types.html\">这里找</a>)。</p>\n<p>java与jni类型基本上一一对应，基本数据类型是值传递，对像使用jobject指针传递，自己做对象映射。<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/types.html\">详细类型链接</a></p>\n<h3 id=\"JNI-References\"><a href=\"#JNI-References\" class=\"headerlink\" title=\"JNI References\"></a>JNI References</h3><p>JNI中把对java对像的引用分为 local-Reference 和 global-Reference两种。</p>\n<ul>\n<li>local Reference不能跨线程访问传递，只有等到native方法返回后才会一起销毁。jvm维护了一个local reference表，有大小限制，典型值是512。在使用中避免传递过大的对多的对像，如对一大的对像List进行循环迭代而忘了手动释放产生的loal reference。</li>\n<li>global reference 可跨线程访问，不用时通过DeleteGlobalReference删除</li>\n<li>两种引用都会影响JVM对其Java对像的回收</li>\n</ul>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><ul>\n<li>JNI可以抛出Java异常</li>\n<li>在JNI回调Java代码后。native并不能捕获java异常，须通过ExceptionOccurred 检查是否有异常发生，native可通过ExceptionClear清除异常，然后执行自己的异常处理过程。</li>\n</ul>\n<h3 id=\"数据缓存\"><a href=\"#数据缓存\" class=\"headerlink\" title=\"数据缓存\"></a>数据缓存</h3><p>为了提高效率，JNI中jclass，jmethod, jfield等可以只查询一次并缓存起来供下次直接使用。</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><ul>\n<li><p>在native中新开线程并想访问Java代码时， 需要先把Attach到JVM, 使用完毕后Detach。Attach后可获取到JNIEnv</p>\n</li>\n<li><p>可通过MonitorEnter和MonitorExit实现java的Synchronize</p>\n</li>\n<li><h3 id=\"大数据的传递\"><a href=\"#大数据的传递\" class=\"headerlink\" title=\"大数据的传递\"></a>大数据的传递</h3><p>在java与native之间传递数据时，需要做相应的对像内存转换，如，把c++的map转换成java的Map。如果数据量较大时，效率是比较低的。一般有以下几种解决方式</p>\n</li>\n<li><p>java NIO 使用了直接内存访问的形式, DirectByteBuffer（堆外内存)。jni给与了支持，NewDirectByteBuffer方法</p>\n</li>\n<li><p>不做数据转换，传一个内存指针上去，（缺点不好维护，有可能导致内存泄漏</p>\n</li>\n<li><p>拆封或调整接口，数据细粒度化</p>\n</li>\n<li><p>懒加载模式， 根据上层使用的数据情况做转换</p>\n</li>\n</ul>\n",
            "tags": []
        }
    ]
}
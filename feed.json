{
    "version": "https://jsonfeed.org/version/1",
    "title": "黑色红桃7",
    "description": "朱新宏的博客",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021-04-23-go-dynamic-type-md/",
            "url": "http://example.com/2021-04-23-go-dynamic-type-md/",
            "title": "go接口动态类型",
            "date_published": "2021-04-23T12:22:42.000Z",
            "content_html": "<h3 id=\"接口使用\"><a href=\"#接口使用\" class=\"headerlink\" title=\"接口使用\"></a>接口使用</h3><p>golang的接口与java里的接口使用上比较相似, 写一个简单的demo</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>\t<span class=\"hljs-string\">&quot;fmt&quot;</span><br>)<br><span class=\"hljs-keyword\">type</span> Animal <span class=\"hljs-keyword\">interface</span> &#123;<br>\tsing()<br>&#125;<br><span class=\"hljs-keyword\">type</span> Bird <span class=\"hljs-keyword\">struct</span> &#123;<br>\tcolor <span class=\"hljs-keyword\">int</span><br>\tweight <span class=\"hljs-keyword\">int</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p Bird)</span><span class=\"hljs-title\">sing</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tfmt.Println( <span class=\"hljs-string\">&quot;zhi-zhi&quot;</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> Cat <span class=\"hljs-keyword\">struct</span> &#123;<br>\tcolor <span class=\"hljs-keyword\">int</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p Cat)</span><span class=\"hljs-title\">sing</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tfmt.Println( <span class=\"hljs-string\">&quot;miao-mi&quot;</span>)<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> anim Animal<br>\tfmt.Printf(<span class=\"hljs-string\">&quot;%T, %v\\n&quot;</span>, anim, anim)<br>\tanim = Bird&#123;color: <span class=\"hljs-number\">1</span>, weight: <span class=\"hljs-number\">100</span>&#125;<br>\tfmt.Printf(<span class=\"hljs-string\">&quot;%T, %v\\n&quot;</span>, anim, anim)<br>\tanim = Cat&#123;color: <span class=\"hljs-number\">2</span>&#125;<br>\tfmt.Printf(<span class=\"hljs-string\">&quot;%T, %v\\n&quot;</span>, anim, anim)<br>\tanim.sing()<br>&#125;<br><span class=\"hljs-comment\">//打印结果:</span><br>&lt;<span class=\"hljs-literal\">nil</span>&gt;, &lt;<span class=\"hljs-literal\">nil</span>&gt;<br>main.Bird, &#123;<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">100</span>&#125;<br>main.Cat, &#123;<span class=\"hljs-number\">2</span>&#125;<br>miao-mi<br></code></pre></td></tr></table></figure>\n<h3 id=\"实现分析\"><a href=\"#实现分析\" class=\"headerlink\" title=\"实现分析\"></a>实现分析</h3><p>反汇编一下代码，找到**anim = Bird{color: 1, weight: 100}**这行代码</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\"><span class=\"hljs-number\">0x0305</span> <span class=\"hljs-number\">00773</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">XORPS</span>   X0, X0<br>//在地址autotmp_27上构造一个Bird<br><span class=\"hljs-number\">0x0308</span> <span class=\"hljs-number\">00776</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">MOVUPS</span>  X0, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_27+<span class=\"hljs-number\">144</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x0310</span> <span class=\"hljs-number\">00784</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">$1</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_27+<span class=\"hljs-number\">144</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x031c</span> <span class=\"hljs-number\">00796</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">$100</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_27+<span class=\"hljs-number\">152</span>(<span class=\"hljs-built_in\">SP</span>)<br>//Bird的itab地址赋值给<span class=\"hljs-built_in\">AX</span>，再赋值给(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x0328</span> <span class=\"hljs-number\">00808</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       LEAQ    go<span class=\"hljs-number\">.</span>itab.<span class=\"hljs-string\">&quot;&quot;</span>.Bird,<span class=\"hljs-string\">&quot;&quot;</span>.Animal(SB), <span class=\"hljs-built_in\">AX</span><br><span class=\"hljs-number\">0x032f</span> <span class=\"hljs-number\">00815</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, (<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x0333</span> <span class=\"hljs-number\">00819</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       LEAQ    <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_27+<span class=\"hljs-number\">144</span>(<span class=\"hljs-built_in\">SP</span>), <span class=\"hljs-built_in\">AX</span><br>//把临时的Bird的地址赋值<span class=\"hljs-number\">8</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x033b</span> <span class=\"hljs-number\">00827</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-number\">8</span>(<span class=\"hljs-built_in\">SP</span>)<br>以itab和构造的Bird为参数调用 runtime<span class=\"hljs-number\">.</span>convT2Inoptr<br><span class=\"hljs-number\">0x0340</span> <span class=\"hljs-number\">00832</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">CALL</span>    runtime<span class=\"hljs-number\">.</span>convT2Inoptr(SB)<br><span class=\"hljs-number\">0x0345</span> <span class=\"hljs-number\">00837</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">16</span>(<span class=\"hljs-built_in\">SP</span>), <span class=\"hljs-built_in\">AX</span><br><span class=\"hljs-number\">0x034a</span> <span class=\"hljs-number\">00842</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">24</span>(<span class=\"hljs-built_in\">SP</span>), <span class=\"hljs-built_in\">CX</span><br><span class=\"hljs-number\">0x034f</span> <span class=\"hljs-number\">00847</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>.anim+<span class=\"hljs-number\">432</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x0357</span> <span class=\"hljs-number\">00855</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">26</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">CX</span>, <span class=\"hljs-string\">&quot;&quot;</span>.anim+<span class=\"hljs-number\">440</span>(<span class=\"hljs-built_in\">SP</span>)<br><br></code></pre></td></tr></table></figure>\n<p><strong>runtime.convT2Inoptr</strong> 实现可以在runtime/iface.go文件下找到:</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">func convT2Inoptr(<span class=\"hljs-built_in\">tab</span> *itab, <span class=\"hljs-built_in\">elem</span> unsafe.Pointer) (i iface) &#123;<br>\tt := <span class=\"hljs-built_in\">tab</span>._type<br>\t<span class=\"hljs-keyword\">if</span> raceenabled &#123;<br>\t\traceReadObjectPC(t, <span class=\"hljs-built_in\">elem</span>, getcallerpc(), funcPC(convT2Inoptr))<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> msanenabled &#123;<br>\t\tmsanread(<span class=\"hljs-built_in\">elem</span>, t.size)<br>\t&#125;<br>\tx := mallocgc(t.size, t, <span class=\"hljs-literal\">false</span>)<br>\tmemmove(x, <span class=\"hljs-built_in\">elem</span>, t.size)<br>\ti.<span class=\"hljs-built_in\">tab</span> = <span class=\"hljs-built_in\">tab</span><br>\ti.data = x<br>\t<span class=\"hljs-built_in\">return</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>返回的iface结构：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\"><span class=\"hljs-built_in\">type</span> iface <span class=\"hljs-keyword\">struct</span> &#123;<br>\t<span class=\"hljs-built_in\">tab</span>  *itab<br>\tdata unsafe.Pointer<br>&#125;<br><br><span class=\"hljs-built_in\">type</span> itab <span class=\"hljs-keyword\">struct</span> &#123;<br>\tinter *interfacetype<br>\t_type *_type<br>\thash  uint32 <span class=\"hljs-comment\">// copy of _type.hash. Used for type switches.</span><br>\t_     [<span class=\"hljs-number\">4</span>]byte<br>\tfun   [<span class=\"hljs-number\">1</span>]uintptr <span class=\"hljs-comment\">// variable sized. fun[0]==0 means _type does not implement inter.</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>变量anim在内存中的表示就是一个iface结构体</li>\n<li>从汇编代码可以看到itab信息是存储在SB(全局变量)中的</li>\n<li>anim的动态类型绑定就是通过在itab绑定类型信息实现的</li>\n</ul>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>\t<span class=\"hljs-string\">&quot;fmt&quot;</span><br>\t<span class=\"hljs-string\">&quot;unsafe&quot;</span><br>)<br><br><span class=\"hljs-keyword\">type</span> Animal <span class=\"hljs-keyword\">interface</span> &#123;<br>\tsing()<br>&#125;<br><span class=\"hljs-keyword\">type</span> Bird <span class=\"hljs-keyword\">struct</span> &#123;<br>\tcolor <span class=\"hljs-keyword\">int</span><br>\tweight <span class=\"hljs-keyword\">int</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p Bird)</span><span class=\"hljs-title\">sing</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tfmt.Printf( <span class=\"hljs-string\">&quot;bird&#123;color: %d, weight:%d&#125; is sing &quot;</span>, p.color, p.weight)<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> itab <span class=\"hljs-keyword\">struct</span> &#123;<br>\tinter unsafe.Pointer<br>\t_type unsafe.Pointer<br>\thash  <span class=\"hljs-keyword\">uint32</span> <span class=\"hljs-comment\">// copy of _type.hash. Used for type switches.</span><br>\t_     [<span class=\"hljs-number\">4</span>]<span class=\"hljs-keyword\">byte</span><br>\tfun   [<span class=\"hljs-number\">1</span>]<span class=\"hljs-keyword\">uintptr</span> <span class=\"hljs-comment\">// variable sized. fun[0]==0 means _type does not implement inter.</span><br>&#125;<br><br><span class=\"hljs-keyword\">type</span> eface <span class=\"hljs-keyword\">struct</span> &#123;<br>\ttab  *itab<br>\tdata *Bird<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> anim Animal = Bird&#123;color: <span class=\"hljs-number\">1</span>, weight: <span class=\"hljs-number\">1999</span>&#125;<br>\t<span class=\"hljs-keyword\">var</span> e = (*eface)(unsafe.Pointer(&amp;anim))<br>\te.data.sing()<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>打印结果: bird{color: 1, weight:1999} is sing <br><br>符合预期</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021-04-22-go-str-byte-md/",
            "url": "http://example.com/2021-04-22-go-str-byte-md/",
            "title": "go str与byte转换",
            "date_published": "2021-04-22T14:10:34.000Z",
            "content_html": "<h3 id=\"string与-byte的转换\"><a href=\"#string与-byte的转换\" class=\"headerlink\" title=\"string与[]byte的转换\"></a>string与[]byte的转换</h3><h4 id=\"一般转换方式\"><a href=\"#一般转换方式\" class=\"headerlink\" title=\"一般转换方式\"></a>一般转换方式</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">bytesFromStr := []<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">&quot;abcdefg&quot;</span>)<br>strFromBytes := <span class=\"hljs-keyword\">string</span>([]<span class=\"hljs-keyword\">byte</span>&#123;<span class=\"hljs-number\">97</span>, <span class=\"hljs-number\">98</span>, <span class=\"hljs-number\">99</span>, <span class=\"hljs-number\">100</span>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"unsafe转换方式\"><a href=\"#unsafe转换方式\" class=\"headerlink\" title=\"unsafe转换方式\"></a>unsafe转换方式</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> StringHeader <span class=\"hljs-keyword\">struct</span> &#123;<br>\tData <span class=\"hljs-keyword\">uintptr</span><br>\tLen  <span class=\"hljs-keyword\">int</span><br>&#125;<br><br><span class=\"hljs-keyword\">type</span> SliceHeader <span class=\"hljs-keyword\">struct</span> &#123;<br>\tData <span class=\"hljs-keyword\">uintptr</span><br>\tLen  <span class=\"hljs-keyword\">int</span><br>\tCap  <span class=\"hljs-keyword\">int</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">str2Bytes</span><span class=\"hljs-params\">(s <span class=\"hljs-keyword\">string</span>)</span> []<span class=\"hljs-title\">byte</span></span> &#123;<br>\tsh := (*StringHeader)(unsafe.Pointer(&amp;s))<br>\t<span class=\"hljs-keyword\">return</span> *(*[]<span class=\"hljs-keyword\">byte</span>)(unsafe.Pointer(&amp;SliceHeader&#123;<br>\t\tData: sh.Data,<br>\t\tLen: sh.Len,<br>\t\tCap: sh.Len,<br>\t&#125;))<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Bytes2Str</span><span class=\"hljs-params\">(b []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">string</span></span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> *(*<span class=\"hljs-keyword\">string</span>)(unsafe.Pointer(&amp;b))<br>&#125;<br></code></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021-04-17-go-interface-md/",
            "url": "http://example.com/2021-04-17-go-interface-md/",
            "title": "go interface{}刨析",
            "date_published": "2021-04-17T12:59:21.000Z",
            "content_html": "<h3 id=\"初识interface\"><a href=\"#初识interface\" class=\"headerlink\" title=\"初识interface{}\"></a>初识interface{}</h3><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">func my<span class=\"hljs-constructor\">Print(<span class=\"hljs-params\">val</span> <span class=\"hljs-params\">interface</span>&#123;&#125;)</span> &#123;<br>    fmt.<span class=\"hljs-constructor\">Printf(<span class=\"hljs-string\">&quot;%v&quot;</span>, <span class=\"hljs-params\">val</span>)</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>用过java的，第一感觉interface{}与Object的差不多。</p>\n<ul>\n<li>Object是任何对象的基类，所有对象都可以转成Object</li>\n<li>interface{}，表面看是一个空接口，而golang规定是只要实现了其方法就实现了该接口。即所有类型都实现了空接口，所以interface{}可接收指针，值对像，接口类型等</li>\n</ul>\n<h3 id=\"interface-内部结构\"><a href=\"#interface-内部结构\" class=\"headerlink\" title=\"interface{}内部结构\"></a>interface{}内部结构</h3><p>我们使用interface{}，一般是通过reflect反射得到他的实际类型</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">func <span class=\"hljs-constructor\">PrintType(<span class=\"hljs-params\">val</span> <span class=\"hljs-params\">interface</span>&#123;&#125;)</span> &#123;<br>    fmt.<span class=\"hljs-constructor\">Printf(<span class=\"hljs-string\">&quot;%s&quot;</span>, <span class=\"hljs-params\">reflect</span>.TypeOf(<span class=\"hljs-params\">arg</span>)</span>.<span class=\"hljs-constructor\">String()</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>跟踪到TypeOf函数中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TypeOf</span><span class=\"hljs-params\">(i <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-title\">Type</span></span> &#123;<br>\teface := *(*emptyInterface)(unsafe.Pointer(&amp;i))<br>\t<span class=\"hljs-keyword\">return</span> toType(eface.typ)<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> emptyInterface <span class=\"hljs-keyword\">struct</span> &#123;<br>\ttyp  *rtype<br>\tword unsafe.Pointer<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> rtype <span class=\"hljs-keyword\">struct</span> &#123;<br>\tsize       <span class=\"hljs-keyword\">uintptr</span><br>\tptrdata    <span class=\"hljs-keyword\">uintptr</span> <span class=\"hljs-comment\">// number of bytes in the type that can contain pointers</span><br>\thash       <span class=\"hljs-keyword\">uint32</span>  <span class=\"hljs-comment\">// hash of type; avoids computation in hash tables</span><br>\ttflag      tflag   <span class=\"hljs-comment\">// extra type information flags</span><br>\talign      <span class=\"hljs-keyword\">uint8</span>   <span class=\"hljs-comment\">// alignment of variable with this type</span><br>\tfieldAlign <span class=\"hljs-keyword\">uint8</span>   <span class=\"hljs-comment\">// alignment of struct field with this type</span><br>\tkind       <span class=\"hljs-keyword\">uint8</span>   <span class=\"hljs-comment\">// enumeration for C</span><br>\t<span class=\"hljs-comment\">// function for comparing objects of this type</span><br>\t<span class=\"hljs-comment\">// (ptr to object A, ptr to object B) -&gt; ==?</span><br>\tequal     <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(unsafe.Pointer, unsafe.Pointer)</span> <span class=\"hljs-title\">bool</span></span><br>\tgcdata    *<span class=\"hljs-keyword\">byte</span>   <span class=\"hljs-comment\">// garbage collection data</span><br>\tstr       nameOff <span class=\"hljs-comment\">// string form</span><br>\tptrToThis typeOff <span class=\"hljs-comment\">// type for pointer to this type, may be zero</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以发现interface{}的实际是一个emptyInterface的struct,下面做一下验证:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//模仿上面自定义的结构体</span><br><span class=\"hljs-keyword\">type</span> emptyInterface <span class=\"hljs-keyword\">struct</span> &#123;<br>\ttyp  *rtype<br>\tword unsafe.Pointer<br>&#125;<br><span class=\"hljs-comment\">//模仿上面自定义的结构体</span><br><span class=\"hljs-keyword\">type</span> rtype <span class=\"hljs-keyword\">struct</span> &#123;<br>\tsize       <span class=\"hljs-keyword\">uintptr</span><br>\tptrdata    <span class=\"hljs-keyword\">uintptr</span> <span class=\"hljs-comment\">// number of bytes in the type that can contain pointers</span><br>\thash       <span class=\"hljs-keyword\">uint32</span>  <span class=\"hljs-comment\">// hash of type; avoids computation in hash tables</span><br>\ttflag      <span class=\"hljs-keyword\">uint8</span>   <span class=\"hljs-comment\">// extra type information flags</span><br>\talign      <span class=\"hljs-keyword\">uint8</span>   <span class=\"hljs-comment\">// alignment of variable with this type</span><br>\tfieldAlign <span class=\"hljs-keyword\">uint8</span>   <span class=\"hljs-comment\">// alignment of struct field with this type</span><br>\tkind       <span class=\"hljs-keyword\">uint8</span><br>\tequal     <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(unsafe.Pointer, unsafe.Pointer)</span> <span class=\"hljs-title\">bool</span></span><br>\tgcdata    *<span class=\"hljs-keyword\">byte</span>   <span class=\"hljs-comment\">// garbage collection data</span><br>\tstr       <span class=\"hljs-keyword\">int32</span> <span class=\"hljs-comment\">// string form</span><br>\tptrToThis <span class=\"hljs-keyword\">int32</span> <span class=\"hljs-comment\">// type for pointer to this type, may be zero</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">transForm</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> *<span class=\"hljs-title\">emptyInterface</span></span> &#123;<br>\t<span class=\"hljs-comment\">//强制类型转换</span><br>\t<span class=\"hljs-keyword\">return</span> (*emptyInterface)(unsafe.Pointer(&amp;obj))<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> a <span class=\"hljs-keyword\">uint64</span> = <span class=\"hljs-number\">999</span><br>\te := transForm(a)<br>    fmt.Println(reflect.Kind(e.typ.kind), *(*<span class=\"hljs-keyword\">uint64</span>)(e.word))<br>&#125;<br><br><span class=\"hljs-comment\">//打印出来uint64 999</span><br></code></pre></td></tr></table></figure>\n<p><strong>验证了我们和猜想，可以发现interface{}的数据是一个指针，那他是如何支持值赋值的呢？如果他只是把word指向了原数据，这又和golang值传递的方式相违背</strong></p>\n<h3 id=\"interface-赋值过程\"><a href=\"#interface-赋值过程\" class=\"headerlink\" title=\"interface{}赋值过程\"></a>interface{}赋值过程</h3><p>为了搞清楚他是如何赋值的，我们写个demo一探究竟：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-keyword\">type</span> TVal <span class=\"hljs-keyword\">struct</span> &#123;<br>\ta <span class=\"hljs-keyword\">int</span><br>\tb <span class=\"hljs-keyword\">string</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">printFace</span><span class=\"hljs-params\">(v <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span>  &#123;<br>\tfmt.Println(v)<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tval := TVal&#123;a: <span class=\"hljs-number\">1999</span>, b: <span class=\"hljs-string\">&quot;abcdefg&quot;</span>&#125;<br>\tprintFace(TVal&#123;a: <span class=\"hljs-number\">1999</span>, b: <span class=\"hljs-string\">&quot;abcdefg&quot;</span>&#125;)<br>\tprintFace(&amp;val)<br>\tt := <span class=\"hljs-number\">10</span><br>\tprintFace(t)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>三种反汇编:</p>\n<ul>\n<li>go build –gcflags=”-l -N” -o helloworld， 去掉优化</li>\n<li>go tool compile -N -S main.go，去掉优化</li>\n<li>go tool objdump -S test &gt; abc.asm</li>\n</ul>\n<p>统一使用第二种方式。</p>\n<h4 id=\"值传递分析\"><a href=\"#值传递分析\" class=\"headerlink\" title=\"值传递分析\"></a>值传递分析</h4><p>截取 <strong>printFace(TVal{a: 1999, b: “abcdefg”})</strong> 汇编代码:</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\"><span class=\"hljs-number\">0x00c6</span> <span class=\"hljs-number\">00198</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       PCDATA  <span class=\"hljs-number\">$0</span>, $-<span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">0x00c6</span> <span class=\"hljs-number\">00198</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">XORPS</span>   X0, X0<br>//autotmp_23 可以看成是一个地址符号，基地址<span class=\"hljs-number\">560</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x00c9</span> <span class=\"hljs-number\">00201</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVUPS</span>  X0, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_23+<span class=\"hljs-number\">560</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x00d1</span> <span class=\"hljs-number\">00209</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">$0</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_23+<span class=\"hljs-number\">576</span>(<span class=\"hljs-built_in\">SP</span>)<br>//把<span class=\"hljs-number\">1999</span>赋值到地址<span class=\"hljs-number\">560</span>(<span class=\"hljs-built_in\">SP</span>)上<br><span class=\"hljs-number\">0x00dd</span> <span class=\"hljs-number\">00221</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">$1999</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_23+<span class=\"hljs-number\">560</span>(<span class=\"hljs-built_in\">SP</span>)<br>//字符串的地址(SB为全局变量, go<span class=\"hljs-number\">.</span>string.<span class=\"hljs-string\">&quot;abcdefg&quot;</span>可以看成地址符号),赋值给<span class=\"hljs-built_in\">AX</span><br><span class=\"hljs-number\">0x00e9</span> <span class=\"hljs-number\">00233</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       LEAQ    go<span class=\"hljs-number\">.</span>string.<span class=\"hljs-string\">&quot;abcdefg&quot;</span>(SB), <span class=\"hljs-built_in\">AX</span><br>//字符串的地址赋值给<span class=\"hljs-number\">568</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x00f0</span> <span class=\"hljs-number\">00240</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_23+<span class=\"hljs-number\">568</span>(<span class=\"hljs-built_in\">SP</span>)<br>//把字符串长度<span class=\"hljs-number\">7</span>赋值给<span class=\"hljs-number\">576</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x00f8</span> <span class=\"hljs-number\">00248</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">$7</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_23+<span class=\"hljs-number\">576</span>(<span class=\"hljs-built_in\">SP</span>)<br>//获取struct TVal的类型元数据,<br>// autotmp_23的数据为 |<span class=\"hljs-number\">1999</span> (8<span class=\"hljs-built_in\">byte</span>)| str_addr (8<span class=\"hljs-built_in\">byte</span>) | <span class=\"hljs-number\">7</span> (8<span class=\"hljs-built_in\">byte</span>)|,其实就是struct &#123;<span class=\"hljs-keyword\">int</span>, stringHeader&#125;<br><span class=\"hljs-number\">0x0104</span> <span class=\"hljs-number\">00260</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       LEAQ    type.<span class=\"hljs-string\">&quot;&quot;</span>.TVal(SB), <span class=\"hljs-built_in\">AX</span><br>//TVal的类型元数据(_type)地址给<span class=\"hljs-built_in\">SP</span><br><span class=\"hljs-number\">0x010b</span> <span class=\"hljs-number\">00267</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, (<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x010f</span> <span class=\"hljs-number\">00271</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       LEAQ    <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_23+<span class=\"hljs-number\">560</span>(<span class=\"hljs-built_in\">SP</span>), <span class=\"hljs-built_in\">AX</span><br>//autotmp_23地址赋值给<span class=\"hljs-number\">8</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x0117</span> <span class=\"hljs-number\">00279</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-number\">8</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x011c</span> <span class=\"hljs-number\">00284</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       PCDATA  <span class=\"hljs-number\">$1</span>, <span class=\"hljs-number\">$1</span><br><span class=\"hljs-number\">0x011c</span> <span class=\"hljs-number\">00284</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">NOP</span><br>//调用runtime<span class=\"hljs-number\">.</span>convT2E，参数为(<span class=\"hljs-built_in\">SP</span>)(*_type), <span class=\"hljs-number\">8</span>(<span class=\"hljs-built_in\">SP</span>)（struct &#123;<span class=\"hljs-keyword\">int</span>, stringHeader&#125;指针）<br><span class=\"hljs-number\">0x0120</span> <span class=\"hljs-number\">00288</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">CALL</span>    runtime<span class=\"hljs-number\">.</span>convT2E(SB)<br><span class=\"hljs-number\">0x0125</span> <span class=\"hljs-number\">00293</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">16</span>(<span class=\"hljs-built_in\">SP</span>), <span class=\"hljs-built_in\">AX</span><br><span class=\"hljs-number\">0x012a</span> <span class=\"hljs-number\">00298</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">24</span>(<span class=\"hljs-built_in\">SP</span>), <span class=\"hljs-built_in\">CX</span><br><span class=\"hljs-number\">0x012f</span> <span class=\"hljs-number\">00303</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_28+<span class=\"hljs-number\">432</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x0137</span> <span class=\"hljs-number\">00311</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">CX</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_28+<span class=\"hljs-number\">440</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x013f</span> <span class=\"hljs-number\">00319</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>.v+<span class=\"hljs-number\">224</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x0147</span> <span class=\"hljs-number\">00327</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">14</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">CX</span>, <span class=\"hljs-string\">&quot;&quot;</span>.v+<span class=\"hljs-number\">232</span>(<span class=\"hljs-built_in\">SP</span>)<br></code></pre></td></tr></table></figure>\n<p>最后调用runtime.convT2E，看一下源码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\">func convT2E(t *_<span class=\"hljs-keyword\">type</span>, elem <span class=\"hljs-keyword\">unsafe</span>.Pointer) (e eface) &#123;<br>\t<span class=\"hljs-keyword\">if</span> raceenabled &#123;<br>\t\traceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2E))<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> msanenabled &#123;<br>\t\tmsanread(elem, t.size)<br>\t&#125;<br>\tx := mallocgc(t.size, t, <span class=\"hljs-literal\">true</span>)<br>\t<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> We allocate a zeroed object only to overwrite it with actual data.</span><br>\t<span class=\"hljs-comment\">// Figure out how to avoid zeroing. Also below in convT2Eslice, convT2I, convT2Islice.</span><br>\ttypedmemmove(t, x, elem)<br>\te._<span class=\"hljs-keyword\">type</span> = t<br>\te.data = x<br>\t<span class=\"hljs-keyword\">return</span><br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">eface</span></span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> &#123;</span><br>\t_<span class=\"hljs-keyword\">type</span> *_<span class=\"hljs-keyword\">type</span><br>\tdata  <span class=\"hljs-keyword\">unsafe</span>.Pointer<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>** 可以发现里面申请了一块sizeof(type)大小的内存，并初始化为elem。<br>返回值eface和前面的emptyInterface一样 **</p>\n<h4 id=\"指针传递分析\"><a href=\"#指针传递分析\" class=\"headerlink\" title=\"指针传递分析\"></a>指针传递分析</h4><p>截取 <strong>printFace(&amp;val)</strong> 汇编代码:</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\"><span class=\"hljs-number\">0x02a9</span> <span class=\"hljs-number\">00681</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">15</span>)       PCDATA  <span class=\"hljs-number\">$1</span>, $-<span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">0x02a9</span> <span class=\"hljs-number\">00681</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">15</span>)       <span class=\"hljs-keyword\">JMP</span>     <span class=\"hljs-number\">683</span><br>//val地址赋值给<span class=\"hljs-built_in\">AX</span><br><span class=\"hljs-number\">0x02ab</span> <span class=\"hljs-number\">00683</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">15</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-string\">&quot;&quot;</span>.&amp;val+<span class=\"hljs-number\">152</span>(<span class=\"hljs-built_in\">SP</span>), <span class=\"hljs-built_in\">AX</span><br>//<span class=\"hljs-built_in\">AX</span>赋值给<span class=\"hljs-number\">144</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x02b3</span> <span class=\"hljs-number\">00691</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">15</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_26+<span class=\"hljs-number\">144</span>(<span class=\"hljs-built_in\">SP</span>)<br>//struct TVal的类型元数据指针赋值给<span class=\"hljs-built_in\">CX</span><br><span class=\"hljs-number\">0x02bb</span> <span class=\"hljs-number\">00699</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">15</span>)       LEAQ    type.*<span class=\"hljs-string\">&quot;&quot;</span>.TVal(SB), <span class=\"hljs-built_in\">CX</span><br>//<span class=\"hljs-built_in\">CX</span>，即struct TVal的类型元数据指针，赋值给 <span class=\"hljs-number\">400</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x02c2</span> <span class=\"hljs-number\">00706</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">15</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">CX</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_32+<span class=\"hljs-number\">400</span>(<span class=\"hljs-built_in\">SP</span>)<br>//<span class=\"hljs-built_in\">AX</span>，即val的地址赋值给 <span class=\"hljs-number\">408</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x02ca</span> <span class=\"hljs-number\">00714</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">15</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_32+<span class=\"hljs-number\">408</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x02d2</span> <span class=\"hljs-number\">00722</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">15</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">CX</span>, <span class=\"hljs-string\">&quot;&quot;</span>.v+<span class=\"hljs-number\">240</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x02da</span> <span class=\"hljs-number\">00730</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">15</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>.v+<span class=\"hljs-number\">248</span>(<span class=\"hljs-built_in\">SP</span>)<br></code></pre></td></tr></table></figure>\n<p>可以看出只是地址赋值操作</p>\n<h4 id=\"基本类型传递分析\"><a href=\"#基本类型传递分析\" class=\"headerlink\" title=\"基本类型传递分析\"></a>基本类型传递分析</h4><p>截取 ** printFace(t) ** 汇编代码:</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\"><span class=\"hljs-number\">0x046e</span> <span class=\"hljs-number\">01134</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">16</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">$1999</span>, <span class=\"hljs-string\">&quot;&quot;</span>.t+<span class=\"hljs-number\">64</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x0477</span> <span class=\"hljs-number\">01143</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">$1999</span>, (<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x047f</span> <span class=\"hljs-number\">01151</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       PCDATA  <span class=\"hljs-number\">$1</span>, <span class=\"hljs-number\">$0</span><br><span class=\"hljs-number\">0x047f</span> <span class=\"hljs-number\">01151</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       <span class=\"hljs-keyword\">NOP</span><br><span class=\"hljs-number\">0x0480</span> <span class=\"hljs-number\">01152</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       <span class=\"hljs-keyword\">CALL</span>    runtime<span class=\"hljs-number\">.</span>convT64(SB)<br><span class=\"hljs-number\">0x0485</span> <span class=\"hljs-number\">01157</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-number\">8</span>(<span class=\"hljs-built_in\">SP</span>), <span class=\"hljs-built_in\">AX</span><br><span class=\"hljs-number\">0x048a</span> <span class=\"hljs-number\">01162</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_38+<span class=\"hljs-number\">136</span>(<span class=\"hljs-built_in\">SP</span>)<br>//类型元数据地址赋值是一样的<br><span class=\"hljs-number\">0x0492</span> <span class=\"hljs-number\">01170</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       LEAQ    type<span class=\"hljs-number\">.</span><span class=\"hljs-keyword\">int</span>(SB), <span class=\"hljs-built_in\">CX</span><br><span class=\"hljs-number\">0x0499</span> <span class=\"hljs-number\">01177</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">CX</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_37+<span class=\"hljs-number\">384</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x04a1</span> <span class=\"hljs-number\">01185</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>..autotmp_37+<span class=\"hljs-number\">392</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x04a9</span> <span class=\"hljs-number\">01193</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">CX</span>, <span class=\"hljs-string\">&quot;&quot;</span>.v+<span class=\"hljs-number\">224</span>(<span class=\"hljs-built_in\">SP</span>)<br><span class=\"hljs-number\">0x04b1</span> <span class=\"hljs-number\">01201</span> (main<span class=\"hljs-number\">.</span>go:<span class=\"hljs-number\">17</span>)       <span class=\"hljs-keyword\">MOVQ</span>    <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-string\">&quot;&quot;</span>.v+<span class=\"hljs-number\">232</span>(<span class=\"hljs-built_in\">SP</span>)<br><br>//runtime<span class=\"hljs-number\">.</span>convT64在runtime/iface<span class=\"hljs-number\">.</span>go下<br>func convT64(val uint64) (x unsafe<span class=\"hljs-number\">.</span>Pointer) &#123;<br>\tif val &lt; uint64(len(staticuint64s)) &#123;<br>\t\tx = unsafe<span class=\"hljs-number\">.</span>Pointer(&amp;staticuint64s[val])<br>\t&#125; else &#123;<br>\t\tx = mallocgc(<span class=\"hljs-number\">8</span>, uint64Type, false)<br>\t\t*(*uint64)(x) = val<br>\t&#125;<br>\treturn<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>在runtime/iface.go有一系列的convTXXX方法，用于不同的类型。其主要目的是为了利用缓存，避免频繁的内存分配</p>\n<ul>\n<li><strong>struct { a int}</strong> 这样的结构也适用于这种情况</li>\n<li>常量的情况，会是一个全局变量的指针赋值</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>interface{}在实际中是一个eface的结构体。</li>\n<li>interface{}更像一个包装类</li>\n<li>主要通过reflect来操作</li>\n</ul>\n<p>参考资料:<br><a href=\"https://lrita.github.io/2017/12/12/golang-asm/\">https://lrita.github.io/2017/12/12/golang-asm/</a></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021-04-16-go-chan-md/",
            "url": "http://example.com/2021-04-16-go-chan-md/",
            "title": "go channel",
            "date_published": "2021-04-16T14:06:41.000Z",
            "content_html": "<h3 id=\"channel的功能及使用\"><a href=\"#channel的功能及使用\" class=\"headerlink\" title=\"channel的功能及使用\"></a>channel的功能及使用</h3><p>channel是golang里面实现并发的基础，他主要用于在goroutine之间通信<br>。他与rust中的Channel非常相似，不知道谁模仿谁的。</p>\n<p> channel的使用方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//myChan 本身是一个指针，可以随意在函数参数中传递</span><br><span class=\"hljs-comment\">//无缓存的chan</span><br>myChan := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br><span class=\"hljs-comment\">//有缓存的chan</span><br>myChan := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-comment\">//定义只读/写 chan没有意义，一般用于在函数传递中限制chan的行为</span><br><span class=\"hljs-comment\">//只写chan</span><br>myChan := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> &lt;- <span class=\"hljs-keyword\">int</span>)<br><span class=\"hljs-comment\">//只读chan</span><br>myChan := <span class=\"hljs-built_in\">make</span>(&lt;- <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br><br><span class=\"hljs-comment\">//发送数据到通道中</span><br>myChan &lt;- <span class=\"hljs-number\">1</span><br><br><span class=\"hljs-comment\">//使用阻塞方式从通道中读取数据</span><br>myBlockData := &lt;- myChan<br><span class=\"hljs-comment\">//忽略读取的数据</span><br>&lt;-myChan<br><br><span class=\"hljs-comment\">//使用非阻塞方式从通道中读取数据,一般使用select而非这种方式</span><br>myNoBlockData, ok := &lt;- myChan<br><br><span class=\"hljs-comment\">//循环接收数据， 没有数据时会阻塞，</span><br><span class=\"hljs-comment\">//自己设计条件退出循环,或者调用close(myChan)后也会退出</span><br><span class=\"hljs-keyword\">for</span> data := <span class=\"hljs-keyword\">range</span> myChan &#123;<br>&#125;<br><br><span class=\"hljs-comment\">//关闭chan</span><br><span class=\"hljs-built_in\">close</span>(myChan)<br><br></code></pre></td></tr></table></figure>\n<h5 id=\"chan的缓存\"><a href=\"#chan的缓存\" class=\"headerlink\" title=\"chan的缓存\"></a>chan的缓存</h5><ul>\n<li>无缓存的情况，当没有chan的读操作取时，chan的数据的写入会阻塞</li>\n<li>无缓存的情况，当没有chan的写操作取时，chan的数据的读入会阻塞</li>\n<li>有缓存的情况，类似于生产者和消费者模式</li>\n</ul>\n<h5 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h5><ul>\n<li>给关闭的chan发消息会panic</li>\n<li>从已关闭的chan读消息,读出来的值为chan通道类型的空值</li>\n</ul>\n<h3 id=\"channel的实现\"><a href=\"#channel的实现\" class=\"headerlink\" title=\"channel的实现\"></a>channel的实现</h3><p>channel的源码实现在runtime/chan.go下面</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> hchan <span class=\"hljs-keyword\">struct</span> &#123;<br>\tqcount   <span class=\"hljs-keyword\">uint</span>           <span class=\"hljs-comment\">// total data in the queue</span><br>\tdataqsiz <span class=\"hljs-keyword\">uint</span>           <span class=\"hljs-comment\">// size of the circular queue</span><br>\tbuf      unsafe.Pointer <span class=\"hljs-comment\">// points to an array of dataqsiz elements</span><br>\telemsize <span class=\"hljs-keyword\">uint16</span><br>\tclosed   <span class=\"hljs-keyword\">uint32</span><br>\telemtype *_type <span class=\"hljs-comment\">// element type</span><br>\tsendx    <span class=\"hljs-keyword\">uint</span>   <span class=\"hljs-comment\">// send index</span><br>\trecvx    <span class=\"hljs-keyword\">uint</span>   <span class=\"hljs-comment\">// receive index</span><br>\trecvq    waitq  <span class=\"hljs-comment\">// list of recv waiters</span><br>\tsendq    waitq  <span class=\"hljs-comment\">// list of send waiters</span><br><br>\t<span class=\"hljs-comment\">// lock protects all fields in hchan, as well as several</span><br>\t<span class=\"hljs-comment\">// fields in sudogs blocked on this channel.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// Do not change another G&#x27;s status while holding this lock</span><br>\t<span class=\"hljs-comment\">// (in particular, do not ready a G), as this can deadlock</span><br>\t<span class=\"hljs-comment\">// with stack shrinking.</span><br>\tlock mutex<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"channel的创建过程\"><a href=\"#channel的创建过程\" class=\"headerlink\" title=\"channel的创建过程\"></a>channel的创建过程</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\">func <span class=\"hljs-title\">makechan</span><span class=\"hljs-params\">(t *chantype, size <span class=\"hljs-keyword\">int</span>)</span> *hchan </span>&#123;<br>\telem := t.elem<br><br>\t<span class=\"hljs-comment\">// compiler checks this but be safe.</span><br>\t<span class=\"hljs-keyword\">if</span> elem.size &gt;= <span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">16</span> &#123;<br>\t\t<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">throw</span></span>(<span class=\"hljs-string\">&quot;makechan: invalid channel element type&quot;</span>)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> hchanSize%maxAlign != <span class=\"hljs-number\">0</span> || elem.align &gt; maxAlign &#123;<br>\t\t<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">throw</span></span>(<span class=\"hljs-string\">&quot;makechan: bad alignment&quot;</span>)<br>\t&#125;<br><br>\tmem, overflow := math.<span class=\"hljs-built_in\">MulUintptr</span>(elem.size, <span class=\"hljs-built_in\">uintptr</span>(size))<br>\t<span class=\"hljs-keyword\">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-built_in\">panic</span>(<span class=\"hljs-built_in\">plainError</span>(<span class=\"hljs-string\">&quot;makechan: size out of range&quot;</span>))<br>\t&#125;<br>\t<br>\tvar c *hchan<br>\t<span class=\"hljs-keyword\">switch</span> &#123;<br>\t<span class=\"hljs-keyword\">case</span> mem == <span class=\"hljs-number\">0</span>:<br>\t\t<span class=\"hljs-comment\">// Queue or element size is zero.</span><br>\t\tc = (*hchan)(<span class=\"hljs-built_in\">mallocgc</span>(hchanSize, nil, <span class=\"hljs-literal\">true</span>))<br>\t\t<span class=\"hljs-comment\">// Race detector uses this location for synchronization.</span><br>\t\tc.buf = c.<span class=\"hljs-built_in\">raceaddr</span>()<br>\t<span class=\"hljs-keyword\">case</span> elem.ptrdata == <span class=\"hljs-number\">0</span>:<br>\t\t<span class=\"hljs-comment\">// Elements do not contain pointers.</span><br>\t\t<span class=\"hljs-comment\">// Allocate hchan and buf in one call.</span><br>\t\tc = (*hchan)(<span class=\"hljs-built_in\">mallocgc</span>(hchanSize+mem, nil, <span class=\"hljs-literal\">true</span>))<br>\t\tc.buf = <span class=\"hljs-built_in\">add</span>(unsafe.<span class=\"hljs-built_in\">Pointer</span>(c), hchanSize)<br>\t<span class=\"hljs-keyword\">default</span>:<br>\t\t<span class=\"hljs-comment\">// Elements contain pointers.</span><br>\t\tc = <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">new</span></span>(hchan)<br>\t\tc.buf = <span class=\"hljs-built_in\">mallocgc</span>(mem, elem, <span class=\"hljs-literal\">true</span>)<br>\t&#125;<br><br>\tc.elemsize = <span class=\"hljs-built_in\">uint16</span>(elem.size)<br>\tc.elemtype = elem<br>\tc.dataqsiz = <span class=\"hljs-built_in\">uint</span>(size)<br>\t<span class=\"hljs-built_in\">lockInit</span>(&amp;c.lock, lockRankHchan)<br><br>\t<span class=\"hljs-keyword\">if</span> debugChan &#123;<br>\t\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;makechan: chan=&quot;</span>, c, <span class=\"hljs-string\">&quot;; elemsize=&quot;</span>, elem.size, <span class=\"hljs-string\">&quot;; dataqsiz=&quot;</span>, size, <span class=\"hljs-string\">&quot;\\n&quot;</span>)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>先判断容量大小</li>\n<li>计算chan队列需要的缓存大小</li>\n<li><ol>\n<li>如果为空队列， 则直接用mallocgc分配一个hchan的对像</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>如果缓存的元素不是指针类型的，则直接用mallocgc分配一整块内存（包括hchan和队列</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>元素包含指针，则先在堆上分配一个hchan对像,再用mallocgc分配chan队列的大小</li>\n</ol>\n</li>\n<li>mallocgc分两种情况，size较小时直接从P的缓存列表中获取，较大时 (&gt;32 kB)直接在堆上分配</li>\n</ul>\n<h3 id=\"channel的缓存\"><a href=\"#channel的缓存\" class=\"headerlink\" title=\"channel的缓存\"></a>channel的缓存</h3><p>hchan中与缓存有关的字段：</p>\n<ul>\n<li>buf 环形队列的地址</li>\n<li>sendx 环形队列的发送地址</li>\n<li>recvx 环形队列的接受地址</li>\n</ul>\n<p>根据代码可以得面缓存的结构如下图所示:</p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/70e1ba4f25d0499b923cafcb2cfa8c7c/xmlnote/WEBRESOURCE94bf6c743675b23712b98382c174bd89/4832\" alt=\"image\"></p>\n<p>至于为什么会根据元素类型中包含指针来设计不同的结构，我觉得主要原因是考虑gc时会改变指针的地址。</p>\n<h3 id=\"chan的发送过程\"><a href=\"#chan的发送过程\" class=\"headerlink\" title=\"chan的发送过程\"></a>chan的发送过程</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">chansend</span><span class=\"hljs-params\">(c *hchan, ep unsafe.Pointer, block <span class=\"hljs-keyword\">bool</span>, callerpc <span class=\"hljs-keyword\">uintptr</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;<br>\t...<br>\t<span class=\"hljs-comment\">//非阻塞，未关闭，且缓存满了直接返回</span><br>\t<span class=\"hljs-keyword\">if</span> !block &amp;&amp; c.closed == <span class=\"hljs-number\">0</span> &amp;&amp; full(c) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>    ...<br>    <span class=\"hljs-comment\">//操作之前先锁住</span><br>\tlock(&amp;c.lock)<br>    ...<br>    <span class=\"hljs-comment\">//从接收队列中取一个接收者，把消息发送给他</span><br>\t<span class=\"hljs-keyword\">if</span> sg := c.recvq.dequeue(); sg != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tsend(c, sg, ep, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class=\"hljs-number\">3</span>)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br>    ...<br>   <span class=\"hljs-comment\">//没有接收者时，队列未满，则入缓存队列</span><br>\t<span class=\"hljs-keyword\">if</span> c.qcount &lt; c.dataqsiz &#123;<br>\t\t<span class=\"hljs-comment\">// Space is available in the channel buffer. Enqueue the element to send.</span><br>\t\tqp := chanbuf(c, c.sendx)<br>\t\t<span class=\"hljs-keyword\">if</span> raceenabled &#123;<br>\t\t\traceacquire(qp)<br>\t\t\tracerelease(qp)<br>\t\t&#125;<br>\t\ttypedmemmove(c.elemtype, qp, ep)<br>\t\tc.sendx++<br>\t\t<span class=\"hljs-keyword\">if</span> c.sendx == c.dataqsiz &#123;<br>\t\t\tc.sendx = <span class=\"hljs-number\">0</span><br>\t\t&#125;<br>\t\tc.qcount++<br>\t\tunlock(&amp;c.lock)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br>    ...<br><br>\t<span class=\"hljs-comment\">// 获取与当前的goroutine相关的sudog并入到发送等待队列</span><br>\tgp := getg()<br>\tmysg := acquireSudog()<br>\t...<br>\tc.sendq.enqueue(mysg)<br>\t<br>\t<span class=\"hljs-comment\">//通知P阻塞，并阻塞住</span><br>\tatomic.Store8(&amp;gp.parkingOnChan, <span class=\"hljs-number\">1</span>)<br>\tgopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class=\"hljs-number\">2</span>)<br>\t...<br>\t<br>\treleaseSudog(mysg)<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"channel的接收过程\"><a href=\"#channel的接收过程\" class=\"headerlink\" title=\"channel的接收过程\"></a>channel的接收过程</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">chanrecv</span><span class=\"hljs-params\">(c *hchan, ep unsafe.Pointer, block <span class=\"hljs-keyword\">bool</span>)</span> <span class=\"hljs-params\">(selected, received <span class=\"hljs-keyword\">bool</span>)</span></span> &#123;<br>\t...<br>\t<span class=\"hljs-comment\">//非阻塞</span><br>\t<span class=\"hljs-comment\">//无缓存情况时无发送等待 或 缓存为空</span><br>\t<span class=\"hljs-keyword\">if</span> !block &amp;&amp; empty(c) &#123;<br>\t    <span class=\"hljs-comment\">//没关闭，直接返回</span><br>\t\t<span class=\"hljs-keyword\">if</span> atomic.Load(&amp;c.closed) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span><br>\t\t&#125;<br>\t     <span class=\"hljs-comment\">//关闭，则产生select事件</span><br>\t\t<span class=\"hljs-keyword\">if</span> empty(c) &#123;<br>\t\t    ...<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125;<br>    ...<br>    <span class=\"hljs-comment\">//操作前先锁住</span><br>\tlock(&amp;c.lock)<br><br>    <span class=\"hljs-comment\">//关闭了且缓存为空,产生select事件</span><br>\t<span class=\"hljs-keyword\">if</span> c.closed != <span class=\"hljs-number\">0</span> &amp;&amp; c.qcount == <span class=\"hljs-number\">0</span> &#123;<br>\t\t...<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">false</span><br>\t&#125;<br>    <span class=\"hljs-comment\">//从发送等待队列中取出发送者,把数据给ep(接受者数据地址)</span><br>\t<span class=\"hljs-keyword\">if</span> sg := c.sendq.dequeue(); sg != <span class=\"hljs-literal\">nil</span> &#123;<br>\t    ...<br>\t\trecv(c, sg, ep, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class=\"hljs-number\">3</span>)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">true</span><br>\t&#125;<br>    <span class=\"hljs-comment\">//没有发送者时，当缓存中有数据时,从缓存中取一个数据</span><br>\t<span class=\"hljs-keyword\">if</span> c.qcount &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-comment\">// Receive directly from queue</span><br>\t\tqp := chanbuf(c, c.recvx)<br>\t    ...<br>\t\t<span class=\"hljs-keyword\">if</span> ep != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\ttypedmemmove(c.elemtype, ep, qp)<br>\t\t&#125;<br>\t\ttypedmemclr(c.elemtype, qp)<br>\t\tc.recvx++<br>\t\t<span class=\"hljs-keyword\">if</span> c.recvx == c.dataqsiz &#123;<br>\t\t\tc.recvx = <span class=\"hljs-number\">0</span><br>\t\t&#125;<br>\t\tc.qcount--<br>\t\tunlock(&amp;c.lock)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">true</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">//缓存中也没有数据时,获取一个与当前goroutine相关的sudog，并入到接收队列中</span><br>\tgp := getg()<br>\tmysg := acquireSudog()<br>    ...<br>\tc.recvq.enqueue(mysg)<br>    <span class=\"hljs-comment\">//通知P阻塞，并阻塞住</span><br>\tatomic.Store8(&amp;gp.parkingOnChan, <span class=\"hljs-number\">1</span>)<br>\tgopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class=\"hljs-number\">2</span>)<br>    ...<br>    阻塞完后，说明有数据来了，产生<span class=\"hljs-keyword\">select</span>事件<br>\treleaseSudog(mysg)<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>, !closed<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"chan的关闭过程\"><a href=\"#chan的关闭过程\" class=\"headerlink\" title=\"chan的关闭过程\"></a>chan的关闭过程</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">func closechan(c *hchan) &#123;<br>    <span class=\"hljs-comment\">//关闭一个空的chan会崩溃</span><br>\t<span class=\"hljs-keyword\">if</span> c == nil &#123;<br>\t\tpanic(plainError(<span class=\"hljs-string\">&quot;close of nil channel&quot;</span>))<br>\t&#125;<br>    <span class=\"hljs-comment\">//操作之前先锁住</span><br>\tlock(&amp;c.lock)<br>\t<span class=\"hljs-comment\">//关闭一个关闭的chan也会崩溃</span><br>\t<span class=\"hljs-keyword\">if</span> c<span class=\"hljs-selector-class\">.closed</span> != <span class=\"hljs-number\">0</span> &#123;<br>\t\tunlock(&amp;c.lock)<br>\t\tpanic(plainError(<span class=\"hljs-string\">&quot;close of closed channel&quot;</span>))<br>\t&#125;<br>    ...<br>    <span class=\"hljs-comment\">//设置为关闭</span><br>\tc<span class=\"hljs-selector-class\">.closed</span> = <span class=\"hljs-number\">1</span><br><br>\t<span class=\"hljs-selector-tag\">var</span> glist gList<br><br>\t<span class=\"hljs-comment\">// 释放所有的接收者</span><br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\tsg := c<span class=\"hljs-selector-class\">.recvq</span><span class=\"hljs-selector-class\">.dequeue</span>()<br>\t    ...<br>\t\tglist<span class=\"hljs-selector-class\">.push</span>(gp)<br>\t&#125;<br><br>    <span class=\"hljs-comment\">//// 释放所有的发送等待者，他们会panic</span><br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\tsg := c<span class=\"hljs-selector-class\">.sendq</span><span class=\"hljs-selector-class\">.dequeue</span>()<br>\t\t...<br>\t\tglist<span class=\"hljs-selector-class\">.push</span>(gp)<br>\t&#125;<br>\tunlock(&amp;c.lock)<br><br>\t<span class=\"hljs-comment\">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span><br>\t<span class=\"hljs-keyword\">for</span> !glist<span class=\"hljs-selector-class\">.empty</span>() &#123;<br>\t\tgp := glist<span class=\"hljs-selector-class\">.pop</span>()<br>\t\tgp<span class=\"hljs-selector-class\">.schedlink</span> = <span class=\"hljs-number\">0</span><br>\t\tgoready(gp, <span class=\"hljs-number\">3</span>)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-20-rust-static/",
            "url": "http://example.com/2018-11-20-rust-static/",
            "title": "rust static详解",
            "date_published": "2018-11-22T12:46:11.000Z",
            "content_html": "<h3 id=\"static-语法\"><a href=\"#static-语法\" class=\"headerlink\" title=\"static 语法\"></a>static 语法</h3><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">static mut? IDENTIFER: <span class=\"hljs-keyword\">Type</span> <span class=\"hljs-type\">(= </span>Expresssion)?;<br></code></pre></td></tr></table></figure>\n<p>其中mut可有可无，Expresssion为表达式，可以没有。</p>\n<h3 id=\"static与常量有区别\"><a href=\"#static与常量有区别\" class=\"headerlink\" title=\"static与常量有区别\"></a>static与常量有区别</h3><ul>\n<li>static有自己的内存地址，其生命周期是‘static的，常量没有</li>\n<li>所有的对static item的引用指向同一个地址，而每个常量都有自己的地址</li>\n<li>static的类型必须是Sync的，跨线程访问</li>\n</ul>\n<h3 id=\"mut-static\"><a href=\"#mut-static\" class=\"headerlink\" title=\"mut static\"></a>mut static</h3><p>如果一个static item是mut的，并发访问时可能会有问题，所以对他的引用是unsafe的。我们要自己确保他的正确性。</p>\n<h3 id=\"static-变量\"><a href=\"#static-变量\" class=\"headerlink\" title=\"static 变量\"></a>static 变量</h3><p>按照static的语法定义变量时经常遇到这样的错误:</p>\n<blockquote>\n<p>calls in statics are limited to constant functions, tuple structs and tuple variants</p>\n</blockquote>\n<p>也就是说上面的Expresssion只是条件的。只能是常量函数，tuple结构等。而不能像Java语言一样 static Object STATIC_OBJ = new Object();</p>\n<p>其中主要的区别在于是static的初始化必须是在编译期可确定的。也就是说其内存大小是在编译期确定的，而Java是在运行时。</p>\n<h3 id=\"lazy-static\"><a href=\"#lazy-static\" class=\"headerlink\" title=\"lazy_static\"></a>lazy_static</h3><p>由于rust static在编译期确定大小的特性，一些rust程序员在编写代码时产生了诸多不便，就有了<a href=\"https://github.com/rust-lang-nursery/lazy-static.rs\">lazy_static</a>这个库。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\">lazy_static! &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">ref</span> HASHMAP: HashMap&lt;<span class=\"hljs-built_in\">u32</span>, &amp;<span class=\"hljs-symbol\">&#x27;static</span> <span class=\"hljs-built_in\">str</span>&gt; = &#123;<br>        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> m = HashMap::new();<br>        m.insert(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>);<br>        m.insert(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>);<br>        m.insert(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;baz&quot;</span>);<br>        m<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>lazy_static是第一次使用时调用初始化，相当于把初始化挪到了运行时。</p>\n<h3 id=\"lazy-mut\"><a href=\"#lazy-mut\" class=\"headerlink\" title=\"lazy_mut\"></a>lazy_mut</h3><p><a href=\"https://docs.rs/lazy_mut/0.1.0/lazy_mut/\">lazy_mut</a>是用来解决变量延迟初始化的, 也包括static mut。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-20-rust-tokio0-1/",
            "url": "http://example.com/2018-11-20-rust-tokio0-1/",
            "title": "tokio0.1分析",
            "date_published": "2018-11-20T11:28:18.000Z",
            "content_html": "<h1 id=\"关于-tokio\"><a href=\"#关于-tokio\" class=\"headerlink\" title=\"关于 tokio\"></a>关于 tokio</h1><h2 id=\"what-is-tokio\"><a href=\"#what-is-tokio\" class=\"headerlink\" title=\"what is tokio\"></a>what is tokio</h2><p>tokio是一个rust语言的异步编程框架，是一个基于事件驱动和非阻塞I/O的框架。在上层设计上，它提供了一些主要组件：</p>\n<ul>\n<li>多线程，任务窃取(work-stealing)的task <a href=\"https://tokio-rs.github.io/tokio/tokio/runtime/index.html\">scheduler</a> (runtime)</li>\n<li>由操作系统的事件队列（epoll,kqueue,IOCP等）支撑的<a href=\"https://docs.rs/tokio/0.1.1/tokio/reactor/index.html\">reactor</a></li>\n<li>异步<a href=\"https://docs.rs/tokio/0.1/tokio/net/index.html\">TCP和UDP</a>套接字</li>\n</ul>\n<h2 id=\"tokio-优势\"><a href=\"#tokio-优势\" class=\"headerlink\" title=\"tokio 优势\"></a>tokio 优势</h2><ul>\n<li>零成本抽象，tokio是基于futures的。</li>\n<li>并发，tokio提供了多线程，work-stealing,scheduler。在现代多核cpu的情况下你可以充分利用他们提高应用的性能。</li>\n<li>非阻塞，高性能，当涉及到网络时，tokio会非常有效的使用系统，如linux上的<a href=\"http://man7.org/linux/man-pages/man7/epoll.7.html\">epoll</a>,bsd平台的<a href=\"https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\">kqueue</a>,Windows的<a href=\"https://docs.microsoft.com/en-us/windows/desktop/fileio/i-o-completion-ports\">I/O completion ports</a>,他们可以在单线程中进行多路复用，批量接收系统通知，减少系统调用。<blockquote>\n<p> Because Tokio uses a poll based model, the problem mostly just goes away. Producers are lazy by default. They will not produce any data unless the consumer asks them to. This is built into Tokio’s foundation.</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>Reliable，api清晰易用，使用rust不会有太多的内存问题。</p>\n</li>\n<li><p>BackPressure，在基于push的系统中，当生产者生产数据的速度超过了消费者消费的速度，数据就会暂存在内存中。除非生产者停止生产，否则系统就会因为内存耗尽而崩溃。消费者通知生产者放慢生产的能力就是BackPressure。在tokio中利用<a href=\"https://tokio.rs/docs/getting-started/futures/#poll-based-futures\">poll</a>的方式很好的解决了这个问题。</p>\n</li>\n<li><p>Cancellation</p>\n<blockquote>\n<p>Because of Tokio’s poll based model, computations do no work unless they are polled. Dependents of that computation hold a future representing the result of that computation. If the result is no longer needed, the future is dropped. At this point, the computation will no longer be polled and thus perform no more work.</p>\n</blockquote>\n<blockquote>\n<p>Thanks to Rust’s ownership model, the computation is able to implement drop handles to detect the future being dropped. This allows it to perform any necessary cleanup work.</p>\n</blockquote>\n</li>\n<li><p>轻量级框架</p>\n</li>\n<li><p>没有垃圾回收</p>\n</li>\n</ul>\n<h2 id=\"tokio的结构\"><a href=\"#tokio的结构\" class=\"headerlink\" title=\"tokio的结构\"></a>tokio的结构</h2><p>结构总体抽象为Futures,Tasks和Executor,并提供了提供了Timer等基础设施。tokio快速，可靠，且可扩展。<br>Tokio 是一个事件驱动的非阻塞I/O框架，用于rust编程语言编写异步应用。在高层设计上，这些组件提供了很好的抽象，大大简化了编码工作。</p>\n<h3 id=\"tokio的依赖\"><a href=\"#tokio的依赖\" class=\"headerlink\" title=\"tokio的依赖\"></a>tokio的依赖</h3><p>tokio主要的依赖有futures,mio(基于异步事件通知的高性能I/O库)</p>\n<h4 id=\"mio\"><a href=\"#mio\" class=\"headerlink\" title=\"mio\"></a>mio</h4><p>参见mio模块</p>\n<h4 id=\"future\"><a href=\"#future\" class=\"headerlink\" title=\"future\"></a>future</h4><p>参见future模块</p>\n<h3 id=\"tokio分析\"><a href=\"#tokio分析\" class=\"headerlink\" title=\"tokio分析\"></a>tokio分析</h3><p>tokio主要分clock,codec,executor,fs,io,net,reactor,runtime,timer这几个模块。这里挑几个主要介绍。</p>\n<h4 id=\"executor\"><a href=\"#executor\" class=\"headerlink\" title=\"executor\"></a>executor</h4><p>executor的作用是执行任务。在tokio执行模型中，futures是懒模式，也就是说当一个future被创建时是不会执行的，为了让他工作，我们要把化丢到一个executor里。在executor里的future就叫做task。<br>当task被通知时，exectuor确保future的poll方法会被执行。executor一般有有两种模型，单线程和多线程，在runtime模块中都有实现。</p>\n<h5 id=\"DefaultExecutor\"><a href=\"#DefaultExecutor\" class=\"headerlink\" title=\"DefaultExecutor\"></a>DefaultExecutor</h5><p><a href=\"https://docs.rs/tokio-executor/0.1.5/src/tokio_executor/global.rs.html#18-20\">DefaultExecutor</a>实现了<a href=\"https://docs.rs/tokio/0.1/tokio/executor/trait.Executor.html\">tokio::executor::Executor</a>,同样也实现了future的Executor trait这样就可以和futures库联系起来。<br>我们来分析一下他的源码：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Debug, Clone)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">DefaultExecutor</span></span> &#123;<br>    _dummy: (),<br>&#125;<br><br><span class=\"hljs-keyword\">impl</span> DefaultExecutor &#123;<br>   <br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">current</span></span>() -&gt; DefaultExecutor &#123;<br>        DefaultExecutor &#123;<br>            _dummy: (),<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-meta\">#[inline]</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_current</span></span>&lt;F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> Executor) -&gt; R, R&gt;(f: F) -&gt; <span class=\"hljs-built_in\">Option</span>&lt;R&gt; &#123;<br>        EXECUTOR.with(|current_executor| &#123;<br>            <span class=\"hljs-keyword\">match</span> current_executor.replace(State::Active) &#123;<br>                State::Ready(executor_ptr) =&gt; &#123;<br>                    <span class=\"hljs-keyword\">let</span> executor = <span class=\"hljs-keyword\">unsafe</span> &#123; &amp;<span class=\"hljs-keyword\">mut</span> *executor_ptr &#125;;<br>                    <span class=\"hljs-keyword\">let</span> result = f(executor);<br>                    current_executor.set(State::Ready(executor_ptr));<br>                    <span class=\"hljs-literal\">Some</span>(result)<br>                &#125;,<br>                State::Empty | State::Active =&gt; <span class=\"hljs-literal\">None</span>,<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Clone, Copy)]</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">State</span></span> &#123;<br>    <span class=\"hljs-comment\">// default executor not defined</span><br>    Empty,<br>    <span class=\"hljs-comment\">// default executor is defined and ready to be used</span><br>    Ready(*<span class=\"hljs-keyword\">mut</span> Executor),<br>    <span class=\"hljs-comment\">// default executor is currently active (used to detect recursive calls)</span><br>    Active<br>&#125;<br><br><span class=\"hljs-comment\">/// Thread-local tracking the current executor</span><br>thread_local!(<span class=\"hljs-keyword\">static</span> EXECUTOR: Cell&lt;State&gt; = Cell::new(State::Empty));<br></code></pre></td></tr></table></figure>\n\n<p>从源码看DefaultExecutor并没有具体的实现，只是一个空壳。每个线程都有一个指针指向一个设置的Executor，使用的是线程本地变量保存。</p>\n<p><em><strong>那么如何设置该Executor呢？</strong></em></p>\n<p>使用<a href=\"https://docs.rs/tokio-executor/0.1.5/src/tokio_executor/global.rs.html#158-194\">with_default</a>方法，他有一个<a href=\"https://docs.rs/crate/tokio-executor/0.1.5/source/src/enter.rs\">Enter</a>类型的变量，代表的是executor的上下文</p>\n<h2 id=\"Reactor\"><a href=\"#Reactor\" class=\"headerlink\" title=\"Reactor\"></a>Reactor</h2><p>reactor主要用来管理Event loop,reactor用来接收从操作系统的事件(epoll,kqueue,IOCP,…),然后转发给等待的tasks。reactor可以看做是操作系统与futures模型之间的桥梁。<br>reactor从操作系统接收事件后会通知到executor。</p>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> tokio::prelude::*;<br><span class=\"hljs-keyword\">use</span> tokio::net::TcpStream;<br><br><span class=\"hljs-keyword\">let</span> addr = <span class=\"hljs-string\">&quot;93.184.216.34:9243&quot;</span>.parse().unwrap();<br><br><span class=\"hljs-keyword\">let</span> connect_future = TcpStream::connect(&amp;addr);<br><br><span class=\"hljs-keyword\">let</span> task = connect_future<br>    .and_then(|socket| &#123;<br>        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;successfully connected&quot;</span>);<br>        <span class=\"hljs-literal\">Ok</span>(())<br>    &#125;)<br>    .map_err(|e| <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;failed to connect; err=&#123;:?&#125;&quot;</span>, e));<br><br>tokio::run(task);<br></code></pre></td></tr></table></figure>\n<p>调用connect方法后，会立即返回一个ConnectFuture，并不会阻塞当前线程。<br>run方法执行后，会把task放到threadpool中，task会执行一次返回NotReady,此时会放回threadpool等待通知再次执行。<br>当tcp连接建立后，reactor会从操作系统收到相应的事件，并通知threadpool task可以再次执行。</p>\n<p>以上代码并没有涉及到Reactor，是因为他包装在了run方法内，我们稍后分析。</p>\n<h3 id=\"reactor源码分析\"><a href=\"#reactor源码分析\" class=\"headerlink\" title=\"reactor源码分析\"></a><a href=\"https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/lib.rs.html#88-96\">reactor源码分析</a></h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reactor</span></span> &#123;<br>    <span class=\"hljs-comment\">/// Reuse the `mio::Events` value across calls to poll.</span><br>    events: mio::Events,<br><br>    <span class=\"hljs-comment\">/// State shared between the reactor and the handles.</span><br>    inner: Arc&lt;Inner&gt;,<br><br>    _wakeup_registration: mio::Registration,<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inner</span></span> &#123;<br>    <span class=\"hljs-comment\">/// The underlying system event queue.</span><br>    io: mio::Poll,<br><br>    <span class=\"hljs-comment\">/// ABA guard counter</span><br>    next_aba_guard: AtomicUsize,<br><br>    <span class=\"hljs-comment\">/// Dispatch slabs for I/O and futures events</span><br>    io_dispatch: RwLock&lt;Slab&lt;ScheduledIo&gt;&gt;,<br><br>    <span class=\"hljs-comment\">/// Used to wake up the reactor from a call to `turn`</span><br>    wakeup: mio::SetReadiness<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ScheduledIo</span></span> &#123;<br>    aba_guard: <span class=\"hljs-built_in\">usize</span>,<br>    readiness: AtomicUsize,<br>    reader: AtomicTask,<br>    writer: AtomicTask,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们看到了熟悉的东西，mio::Events和mio::Poll这两个。<br>Reactor中有几个主要的方法：</p>\n<ol>\n<li>handle –&gt; Handle 返回该Reactor的一个句柄<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\"><span class=\"hljs-meta\">#[derive(Clone)]</span><br>struct <span class=\"hljs-class\">HandlePriv </span>&#123;<br><span class=\"hljs-symbol\">    inner:</span> Weak<span class=\"hljs-params\">&lt;Inner&gt;</span>,<br>&#125;<br><br></code></pre></td></tr></table></figure></li>\n<li>set_fallback</li>\n<li>turn<br> 从源码中我们可以看到他调用了mio::Poll的poll方法，<strong>并做了事件分发</strong>。</li>\n<li>is_idle</li>\n<li>background –&gt; Result&lt;Background,Error&gt;<br> 在一个后台线程运行该Reactor,通过返回的Background可以控制Reactor。</li>\n<li>impl Park<br> 阻塞当前线程，等待事件发生。</li>\n</ol>\n<h4 id=\"Reactor的Park与UnPark\"><a href=\"#Reactor的Park与UnPark\" class=\"headerlink\" title=\"Reactor的Park与UnPark\"></a>Reactor的Park与UnPark</h4><p>使用的是mio::Registration中机制</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">park</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; io::<span class=\"hljs-built_in\">Result</span>&lt;()&gt; &#123;<br>        <span class=\"hljs-keyword\">self</span>.turn(<span class=\"hljs-literal\">None</span>)?;<br>        <span class=\"hljs-literal\">Ok</span>(())<br>    &#125;<br><span class=\"hljs-comment\">//turn调用 的poll方法    </span><br>    <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">unpark</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-keyword\">ref</span> h) = <span class=\"hljs-keyword\">self</span>.inner &#123;<br>            h.wakeup();<br>        &#125;<br>    &#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">wakeup</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(handle) = <span class=\"hljs-keyword\">self</span>.as_priv() &#123;<br>            handle.wakeup();<br>        &#125;<br>    &#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">wakeup</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(inner) = <span class=\"hljs-keyword\">self</span>.inner() &#123;<br>            inner.wakeup.set_readiness(mio::Ready::readable()).unwrap();<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"Registration\"><a href=\"#Registration\" class=\"headerlink\" title=\"Registration\"></a>Registration</h4><p>一种注册到Reactor中的IO资源，他可以从Reactor接受任务通知。通过register把Evented注册到Reactor中。一个Registeration代表两个stream，一个用于读另一个用于写。</p>\n<h5 id=\"Registration到Reactor的注册过程：\"><a href=\"#Registration到Reactor的注册过程：\" class=\"headerlink\" title=\"Registration到Reactor的注册过程：\"></a>Registration到Reactor的注册过程：</h5><p>1.Registration的<a href=\"https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/registration.rs.html#114-117\">register</a>方法中执行register2方法<br>2. register2中199行根据Evented和Reactor的handle构造了一个Registration的Inner<br>3. 我们可以下构造过程代码419行，425行调用了Reactor中的方法 <a href=\"https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/lib.rs.html#636-663\">add_source</a><br>4. add_source方法的657行调用了poll的注册方法</p>\n<h5 id=\"Registration的通知过程\"><a href=\"#Registration的通知过程\" class=\"headerlink\" title=\"Registration的通知过程\"></a>Registration的通知过程</h5><ol>\n<li>Reactor的<a href=\"https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/lib.rs.html#324-327\">turn</a>方法为入口,他调用了poll方法。</li>\n<li>跳到349行poll方法，352行调用了mio::Poll的poll方法，这里会阻塞，返回事件后370判断是内部唤醒事件还是其他事件，其他事件调用dispatch方法。</li>\n<li>388行 dispatch方法先获取读锁，用token为key取出相应的task想关记录，匹配事件是否对的上，最后调用task.notify()。</li>\n</ol>\n<p> Registration中有两个重要的方法，poll_read_ready,poll_write_ready，他们读取Reactor相关的事件。利用这两个函数可以生成两个Future。</p>\n<h4 id=\"PollEvented\"><a href=\"#PollEvented\" class=\"headerlink\" title=\"PollEvented\"></a>PollEvented</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PollEvented</span></span>&lt;E: Evented&gt; &#123;<br>    io: <span class=\"hljs-built_in\">Option</span>&lt;E&gt;,<br>    inner: Inner,<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inner</span></span> &#123;<br>    registration: Registration,<br><br>    <span class=\"hljs-comment\">/// Currently visible read readiness</span><br>    read_readiness: AtomicUsize,<br><br>    <span class=\"hljs-comment\">/// Currently visible write readiness</span><br>    write_readiness: AtomicUsize,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从代码可以看出了，他关联了Registration。他进一步包装了Evented和Registration。PollEvented实现了Read AsyncRead和Write AsyncWrite trait,对上层使用更友好了。</p>\n<h2 id=\"timer\"><a href=\"#timer\" class=\"headerlink\" title=\"timer\"></a>timer</h2><p>时间相关的工具模块，该模块主要包括以下几个功能：</p>\n<ol>\n<li>Delay,一个future在指定的时间后完成</li>\n<li>Interval ,一个Stream,每隔固定的时间产生一个值，值为时间从开始到现在的时间点。</li>\n<li>Timeout，包装了一个future或Stream，设置一个上限时间，如果在指定的时间内不能完成则会被cancelled或返回error。</li>\n<li><a href=\"https://docs.rs/tokio/0.1/tokio/timer/delay_queue/struct.DelayQueue.html\">DelayQueue</a>, 一个队列，通过insert,inser_at等函数可以操作这个队列。也可以当做一个Stream，当item的请求过期后就会被返回。</li>\n<li><a href=\"https://docs.rs/tokio-timer/0.2.7/tokio_timer/timer/struct.Timer.html\">Timer</a> Timer跟踪管理时间的状态，当Delay的deadline到时会通知它。<br>创建一个Timer,使用park方法阻塞当前线程，通过handle()获取Timer的Handle, Handle可以用于创建Delay</li>\n</ol>\n<h2 id=\"runtime\"><a href=\"#runtime\" class=\"headerlink\" title=\"runtime\"></a><a href=\"https://docs.rs/tokio/0.1/tokio/runtime/index.html\">runtime</a></h2><p>使用tokio时需要Reactor,executor,timer这三者的支持。我们可以手动的把这三者关联起来，但可能比较复杂。如果不想麻烦，我们可以用runtime来把这三者串联并管理起来。</p>\n<p>创建runtime时内部做了以下工作：</p>\n<ul>\n<li>开起一个后台线程执行Reactor,而0.1.11版本以后改为每个工作线程有一个Reactor</li>\n<li>开起一个ThreadPoll用于执行futures</li>\n<li>每个工作线程运行一个Timer实例</li>\n</ul>\n<h3 id=\"runtime的使用\"><a href=\"#runtime的使用\" class=\"headerlink\" title=\"runtime的使用\"></a>runtime的使用</h3><h4 id=\"exapmple\"><a href=\"#exapmple\" class=\"headerlink\" title=\"exapmple\"></a>exapmple</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> tokio::net::TcpListener;<br><br><span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(&amp;addr).unwrap();<br><br><span class=\"hljs-keyword\">let</span> server = listener.incoming()<br>    .map_err(|e| <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;error = &#123;:?&#125;&quot;</span>, e))<br>    .for_each(|socket| &#123;<br>        tokio::spawn(process(socket))<br>    &#125;);<br><br>tokio::run(server);<br></code></pre></td></tr></table></figure>\n<p>可以使用run代替自己创建runtime，run方法会阻塞当前线程直到runtime运行完所有任务。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> tokio::runtime::Runtime;<br><span class=\"hljs-keyword\">use</span> tokio::net::TcpListener;<br><br><span class=\"hljs-keyword\">let</span> listener = TcpListener::bind(&amp;addr).unwrap();<br><span class=\"hljs-keyword\">let</span> server = listener.incoming()<br>    .map_err(|e| <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;error = &#123;:?&#125;&quot;</span>, e))<br>    .for_each(|socket| &#123;<br>        tokio::spawn(process(socket))<br>    &#125;);<br><span class=\"hljs-comment\">// Create the runtime</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> rt = Runtime::new().unwrap();<br><br><span class=\"hljs-comment\">// Spawn the server task</span><br>rt.spawn(server);<br><br><span class=\"hljs-comment\">// Wait until the runtime becomes idle and shut it down.</span><br>rt.shutdown_on_idle()<br>    .wait().unwrap();<br></code></pre></td></tr></table></figure>\n<p>我们也可以自己创建runtime，并调用spawn方法，他会把future放到配置的threadpoll中去运行并立即返回。shutdown_on_idle方法会阻塞直到所有任务运行完并关闭。</p>\n<h4 id=\"runtime的配置\"><a href=\"#runtime的配置\" class=\"headerlink\" title=\"runtime的配置\"></a>runtime的配置</h4><p>ThreadPool使用了work-stealing策略，ThreadPool默认每个cpu core开起一个工作线程</p>\n<ol>\n<li>通过Runtime的new方法生成默认配置的</li>\n<li>通过<a href=\"https://docs.rs/tokio/0.1/tokio/runtime/struct.Builder.html\">Builder</a>来构造一个满足你想要的配置的Runtime。<br>主要的配置参数有clock,核心线程数，最大阻塞线程数，线程空闲时的存活时间，线程名，线程栈大小等。</li>\n</ol>\n<h3 id=\"runtime分析\"><a href=\"#runtime分析\" class=\"headerlink\" title=\"runtime分析\"></a>runtime分析</h3><p><a href=\"https://docs.rs/tokio/0.1/src/tokio/runtime/mod.rs.html#221-490\">source</a></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Runtime</span></span> &#123;<br>    inner: <span class=\"hljs-built_in\">Option</span>&lt;Inner&gt;,<br>&#125;<br><br><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inner</span></span> &#123;<br>    <span class=\"hljs-comment\">/// A handle to one of the per-worker reactors.</span><br>    reactor: Handle,<br><br>    <span class=\"hljs-comment\">/// Task execution pool.</span><br>    pool: threadpool::ThreadPool,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从代码可以看出Runtime封装了一个线程池和reactor，但这个reactor在0.1.11版本后就没有用了。<br>下面主要分析一下future的执行过程：</p>\n<p>1.以Runtime 的<a href=\"https://docs.rs/tokio/0.1/src/tokio/runtime/mod.rs.html#342-347\">spawn</a>方法为入口,调用了threadpool的sender方法返回一个<a href=\"https://tokio-rs.github.io/tokio/tokio_threadpool/struct.Sender.html\">Sender</a>，并调用其<a href=\"https://tokio-rs.github.io/tokio/src/tokio_threadpool/sender.rs.html#128-133\">spawn</a>方法。</p>\n<ol start=\"2\">\n<li>Sender是一个Executor,spawn中主要做了三件事：<ol>\n<li>准备工作，容量及状态检查</li>\n<li>new 一个Task</li>\n<li>调用pool的<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/pool/mod.rs\">submit_to_random</a>方法，把这个task随机提交到某个worker中。</li>\n</ol>\n</li>\n</ol>\n<p>接下来我们找到工作线程的<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/pool/mod.rs\">入口</a>，Pool的spawn_thread方法，里面调用 了worker的do_run:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">do_run</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">bool</span> &#123;<br>        <span class=\"hljs-comment\">// Create another worker... It&#x27;s ok, this is just a new type around</span><br>        <span class=\"hljs-comment\">// `Pool` that is expected to stay on the current thread.</span><br>        CURRENT_WORKER.with(|c| &#123;<br>            c.set(<span class=\"hljs-keyword\">self</span> <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _);<br><br>            <span class=\"hljs-keyword\">let</span> inner = <span class=\"hljs-keyword\">self</span>.inner.clone();<br>            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> sender = Sender &#123; inner &#125;;<br><br>            <span class=\"hljs-comment\">// Enter an execution context</span><br>            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> enter = tokio_executor::enter().unwrap();<br><br>            tokio_executor::with_default(&amp;<span class=\"hljs-keyword\">mut</span> sender, &amp;<span class=\"hljs-keyword\">mut</span> enter, |enter| &#123;<br>                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">Some</span>(<span class=\"hljs-keyword\">ref</span> callback) = <span class=\"hljs-keyword\">self</span>.inner.config.around_worker &#123;<br>                    callback.call(<span class=\"hljs-keyword\">self</span>, enter);<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    <span class=\"hljs-keyword\">self</span>.run();<br>                &#125;<br>            &#125;);<br>        &#125;);<br><br>        <span class=\"hljs-comment\">// Can&#x27;t be in blocking mode and finalization mode</span><br>        <span class=\"hljs-built_in\">debug_assert!</span>(!<span class=\"hljs-keyword\">self</span>.is_blocking.get() || !<span class=\"hljs-keyword\">self</span>.should_finalize.get());<br><br>        <span class=\"hljs-keyword\">self</span>.is_blocking.get()<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>来看一下  <strong>tokio_reactor::with_default:</strong></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\">thread_local!(<span class=\"hljs-keyword\">static</span> CURRENT_REACTOR: RefCell&lt;<span class=\"hljs-built_in\">Option</span>&lt;HandlePriv&gt;&gt; = RefCell::new(<span class=\"hljs-literal\">None</span>));<br><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_default</span></span>&lt;F, R&gt;(handle: &amp;Handle, enter: &amp;<span class=\"hljs-keyword\">mut</span> Enter, f: F) -&gt; R<br><span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> Enter) -&gt; R<br>&#123;<br>    <span class=\"hljs-comment\">// Ensure that the executor is removed from the thread-local context</span><br>    <span class=\"hljs-comment\">// when leaving the scope. This handles cases that involve panicking.</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reset</span></span>;<br><br>    <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Reset &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) &#123;<br>            CURRENT_REACTOR.with(|current| &#123;<br>                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> current = current.borrow_mut();<br>                *current = <span class=\"hljs-literal\">None</span>;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// This ensures the value for the current reactor gets reset even if there</span><br>    <span class=\"hljs-comment\">// is a panic.</span><br>    <span class=\"hljs-keyword\">let</span> _r = Reset;<br><br>    CURRENT_REACTOR.with(|current| &#123;<br>        &#123;<br>            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> current = current.borrow_mut();<br><br>            <span class=\"hljs-built_in\">assert!</span>(current.is_none(), <span class=\"hljs-string\">&quot;default Tokio reactor already set \\</span><br><span class=\"hljs-string\">                    for execution context&quot;</span>);<br><br>            <span class=\"hljs-keyword\">let</span> handle = <span class=\"hljs-keyword\">match</span> handle.as_priv() &#123;<br>                <span class=\"hljs-literal\">Some</span>(handle) =&gt; handle,<br>                <span class=\"hljs-literal\">None</span> =&gt; &#123;<br>                    <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">&quot;`handle` does not reference a reactor&quot;</span>);<br>                &#125;<br>            &#125;;<br><br>            *current = <span class=\"hljs-literal\">Some</span>(handle.clone());<br>        &#125;<br><br>        f(enter)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>实际是调用了里面的闭包，根据config.around_worker里是否设置了callback来决定是调用callback还是调用了run方法。我们找到around_worker的设置地方，在Runtime的Builder的build方法中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">let</span> pool = <span class=\"hljs-keyword\">self</span>.threadpool_builder<br>            .around_worker(<span class=\"hljs-keyword\">move</span> |w, enter| &#123;<br>                <span class=\"hljs-keyword\">let</span> index = w.id().to_usize();<br><br>                tokio_reactor::with_default(&amp;reactor_handles[index], enter, |enter| &#123;<br>                    clock::with_default(&amp;clock, enter, |enter| &#123;<br>                        timer::with_default(&amp;timer_handles[index], enter, |_| &#123;<br>                            w.run();<br>                        &#125;);<br>                    &#125;)<br>                &#125;);<br>            &#125;)<br>        ..............<br>            .build();<br></code></pre></td></tr></table></figure>\n\n<p>来看一下 <strong>clock::with_default 与上面同样的套路：</strong><br> <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"> thread_local!(<span class=\"hljs-keyword\">static</span> CLOCK: Cell&lt;<span class=\"hljs-built_in\">Option</span>&lt;*<span class=\"hljs-keyword\">const</span> Clock&gt;&gt; = Cell::new(<span class=\"hljs-literal\">None</span>));<br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_default</span></span>&lt;F, R&gt;(clock: &amp;Clock, enter: &amp;<span class=\"hljs-keyword\">mut</span> Enter, f: F) -&gt; R<br><span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> Enter) -&gt; R<br>&#123;<br>    CLOCK.with(|cell| &#123;<br>        <span class=\"hljs-built_in\">assert!</span>(cell.get().is_none(), <span class=\"hljs-string\">&quot;default clock already set for execution context&quot;</span>);<br><br>        <span class=\"hljs-comment\">// Ensure that the clock is removed from the thread-local context</span><br>        <span class=\"hljs-comment\">// when leaving the scope. This handles cases that involve panicking.</span><br>        <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reset</span></span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt;(&amp;<span class=\"hljs-symbol\">&#x27;a</span> Cell&lt;<span class=\"hljs-built_in\">Option</span>&lt;*<span class=\"hljs-keyword\">const</span> Clock&gt;&gt;);<br><br>        <span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Reset&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; &#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) &#123;<br>                <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>.set(<span class=\"hljs-literal\">None</span>);<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">let</span> _reset = Reset(cell);<br><br>        cell.set(<span class=\"hljs-literal\">Some</span>(clock <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> Clock));<br><br>        f(enter)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<p>再找到 <strong>timer::with_default也是同样的套路：</strong><br> <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"> thread_local!(<span class=\"hljs-keyword\">static</span> CURRENT_TIMER: RefCell&lt;<span class=\"hljs-built_in\">Option</span>&lt;HandlePriv&gt;&gt; = RefCell::new(<span class=\"hljs-literal\">None</span>));<br> <br> <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_default</span></span>&lt;F, R&gt;(handle: &amp;Handle, enter: &amp;<span class=\"hljs-keyword\">mut</span> Enter, f: F) -&gt; R<br><span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> Enter) -&gt; R<br>&#123;<br>    <span class=\"hljs-comment\">// Ensure that the timer is removed from the thread-local context</span><br>    <span class=\"hljs-comment\">// when leaving the scope. This handles cases that involve panicking.</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reset</span></span>;<br><br>    <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Reset &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) &#123;<br>            CURRENT_TIMER.with(|current| &#123;<br>                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> current = current.borrow_mut();<br>                *current = <span class=\"hljs-literal\">None</span>;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// This ensures the value for the current timer gets reset even if there is</span><br>    <span class=\"hljs-comment\">// a panic.</span><br>    <span class=\"hljs-keyword\">let</span> _r = Reset;<br><br>    CURRENT_TIMER.with(|current| &#123;<br>        &#123;<br>            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> current = current.borrow_mut();<br><br>            <span class=\"hljs-built_in\">assert!</span>(current.is_none(), <span class=\"hljs-string\">&quot;default Tokio timer already set \\</span><br><span class=\"hljs-string\">                    for execution context&quot;</span>);<br><br>            <span class=\"hljs-keyword\">let</span> handle = handle.as_priv()<br>                .unwrap_or_else(|| <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">&quot;`handle` does not reference a timer&quot;</span>));<br><br>            *current = <span class=\"hljs-literal\">Some</span>(handle.clone());<br>        &#125;<br><br>        f(enter)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><br> 最后可以看到运行的是Worker的<a href=\"https://tokio-rs.github.io/tokio/src/tokio_threadpool/worker/mod.rs.html#219-292\">run</a>方法，run方法根据执行的结果进行了状态调整。对看247行try_run_task()方法:<br> <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[inline]</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">try_run_task</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, notify: &amp;Arc&lt;Notifier&gt;) -&gt; <span class=\"hljs-built_in\">bool</span> &#123;<br>       <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.try_run_owned_task(notify) &#123;<br>           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>       &#125;<br><br>       <span class=\"hljs-keyword\">self</span>.try_steal_task(notify)<br>   &#125;<br></code></pre></td></tr></table></figure></p>\n<p> 先进入395行try_run_owned_task方法的实现，调用了458行的run_task方法：<br> <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">run_task</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, task: Arc&lt;Task&gt;, notify: &amp;Arc&lt;Notifier&gt;) &#123;<br>       <span class=\"hljs-keyword\">use</span> task::Run::*;<br>       <span class=\"hljs-keyword\">let</span> run = <span class=\"hljs-keyword\">self</span>.run_task2(&amp;task, notify);<br>       <span class=\"hljs-keyword\">match</span> run &#123;<br>           Idle =&gt; &#123;&#125;<br>           Schedule =&gt; &#123;<br>               <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.is_blocking.get() &#123;<br>                   <span class=\"hljs-keyword\">self</span>.pool.submit_external(task, &amp;<span class=\"hljs-keyword\">self</span>.pool);<br>               &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                   <span class=\"hljs-keyword\">self</span>.entry().push_internal(task);<br>               &#125;<br>           &#125;<br>           Complete =&gt; &#123;<br>               <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> state: pool::State = <span class=\"hljs-keyword\">self</span>.pool.state.load(Acquire).into();<br><br>               <span class=\"hljs-keyword\">loop</span> &#123;<br>                   <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> next = state;<br>                   next.dec_num_futures();<br><br>                   <span class=\"hljs-keyword\">let</span> actual = <span class=\"hljs-keyword\">self</span>.pool.state.compare_and_swap(<br>                       state.into(), next.into(), AcqRel).into();<br><br>                   <span class=\"hljs-keyword\">if</span> actual == state &#123;<br>                       trace!(<span class=\"hljs-string\">&quot;task complete; state=&#123;:?&#125;&quot;</span>, next);<br><br>                       <span class=\"hljs-keyword\">if</span> state.num_futures() == <span class=\"hljs-number\">1</span> &#123;<br>                           <span class=\"hljs-keyword\">if</span> next.is_terminated() &#123;<br>                               <span class=\"hljs-keyword\">self</span>.pool.terminate_sleeping_workers();<br>                           &#125;<br>                       &#125;<br>                       <span class=\"hljs-keyword\">return</span>;<br>                   &#125;<br><br>                   state = actual;<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><br>调用了runtask2方法并对结果做了处理。跟踪到最后一行task.run(),切换到<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/task/mod.rs\">task.run</a>,我们看到task内有一个类型是UnsafeCell&lt;Option&lt;Spawn<BoxFuture>&gt;&gt;,这个就是future实例了。<br>切换到run方法，看以看到他调用了Spawn的<a href=\"https://docs.rs/tokio/0.1/tokio/prelude/task/struct.Spawn.html#method.poll_future_notify\">poll_future_notify</a>方法。这个方法在Future中讲过，最终调用了future的poll方法。</p>\n<h3 id=\"ThreadPool中task的notify\"><a href=\"#ThreadPool中task的notify\" class=\"headerlink\" title=\"ThreadPool中task的notify\"></a>ThreadPool中task的notify</h3><p>找到<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/task/mod.rs\">notify</a>方法</p>\n<pre><code class=\"rust\"> /// Notify the task\n    pub fn notify(me: Arc&lt;Task&gt;, pool: &amp;Arc&lt;Pool&gt;) &#123;\n        if me.schedule() &#123;\n            let _ = pool.submit(me, pool);\n        &#125;\n    &#125;\n</code></pre>\n<p>先判断一下自己的当前状态，然后通过pool把自己提交到线程池中，进入<a href=\"https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/pool/mod.rs\">submit</a>方法，可以看到熟悉的流程了。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-17-rust-mio-md/",
            "url": "http://example.com/2018-11-17-rust-mio-md/",
            "title": "rust mio",
            "date_published": "2018-11-17T13:24:58.000Z",
            "content_html": "<h2 id=\"mio-简介\"><a href=\"#mio-简介\" class=\"headerlink\" title=\"mio 简介\"></a>mio 简介</h2><p>一个高性能的底层IO库，提供了非阻塞的API,事件通知机制，和一些其他构建高性能应用所需要的工具。</p>\n<p>当前支持的平台有：</p>\n<ul>\n<li>linux</li>\n<li>OS X</li>\n<li>Windows</li>\n<li>FreeBSD</li>\n<li>NetBSD</li>\n<li>Android</li>\n<li>IOS</li>\n</ul>\n<h2 id=\"mio的使用\"><a href=\"#mio的使用\" class=\"headerlink\" title=\"mio的使用\"></a>mio的使用</h2><p>创建一个<a href=\"https://docs.rs/mio/0.6.16/mio/struct.Poll.html\">Poll</a>，Poll会从OS是读取你感兴趣的事件放在<a href=\"https://docs.rs/mio/0.6.16/mio/struct.Events.html\">Events</a>中,然后你可以处理这些IO事件。</p>\n<p>他的使用方式和epoll非常像。</p>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> mio::*;<br><span class=\"hljs-keyword\">use</span> mio::net::&#123;TcpListener, TcpStream&#125;;<br><br><span class=\"hljs-comment\">// Setup some tokens to allow us to identify which event is</span><br><span class=\"hljs-comment\">// for which socket.</span><br><span class=\"hljs-keyword\">const</span> SERVER: Token = Token(<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-keyword\">const</span> CLIENT: Token = Token(<span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-keyword\">let</span> addr = <span class=\"hljs-string\">&quot;127.0.0.1:13265&quot;</span>.parse().unwrap();<br><br><span class=\"hljs-comment\">// Setup the server socket</span><br><span class=\"hljs-keyword\">let</span> server = TcpListener::bind(&amp;addr).unwrap();<br><br><span class=\"hljs-comment\">// Create a poll instance</span><br><span class=\"hljs-keyword\">let</span> poll = Poll::new().unwrap();<br><br><span class=\"hljs-comment\">// Start listening for incoming connections</span><br>poll.register(&amp;server, SERVER, Ready::readable(),<br>              PollOpt::edge()).unwrap();<br><br><span class=\"hljs-comment\">// Setup the client socket</span><br><span class=\"hljs-keyword\">let</span> sock = TcpStream::connect(&amp;addr).unwrap();<br><br><span class=\"hljs-comment\">// Register the socket</span><br>poll.register(&amp;sock, CLIENT, Ready::readable(),<br>              PollOpt::edge()).unwrap();<br><br><span class=\"hljs-comment\">// Create storage for events</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> events = Events::with_capacity(<span class=\"hljs-number\">1024</span>);<br><br><span class=\"hljs-keyword\">loop</span> &#123;<br>    poll.poll(&amp;<span class=\"hljs-keyword\">mut</span> events, <span class=\"hljs-literal\">None</span>).unwrap();<br><br>    <span class=\"hljs-keyword\">for</span> event <span class=\"hljs-keyword\">in</span> events.iter() &#123;<br>        <span class=\"hljs-keyword\">match</span> event.token() &#123;<br>            SERVER =&gt; &#123;<br>                <span class=\"hljs-comment\">// Accept and drop the socket immediately, this will close</span><br>                <span class=\"hljs-comment\">// the socket and notify the client of the EOF.</span><br>                <span class=\"hljs-keyword\">let</span> _ = server.accept();<br>            &#125;<br>            CLIENT =&gt; &#123;<br>                <span class=\"hljs-comment\">// The server just shuts down the socket, let&#x27;s just exit</span><br>                <span class=\"hljs-comment\">// from our event loop.</span><br>                <span class=\"hljs-keyword\">return</span>;<br>            &#125;<br>            _ =&gt; <span class=\"hljs-built_in\">unreachable!</span>(),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"mio分析\"><a href=\"#mio分析\" class=\"headerlink\" title=\"mio分析\"></a>mio分析</h2><p>mio结构相对比较简单，分event和net两个module,加和Registration相关的类。</p>\n<h3 id=\"event-module\"><a href=\"#event-module\" class=\"headerlink\" title=\"event module\"></a>event module</h3><p>struct Event 代表一个产生的事件<br>struct Events 代表事件的集合，可生成迭代器使用</p>\n<p>evented trait 主要用于往Poll里注册感兴趣的事件。</p>\n<h3 id=\"net-module\"><a href=\"#net-module\" class=\"headerlink\" title=\"net module\"></a>net module</h3><p>提供了TcpStream,TcpListener,UdpScoket的poll方式的封装。</p>\n<h3 id=\"Registration\"><a href=\"#Registration\" class=\"headerlink\" title=\"Registration\"></a>Registration</h3><p>用于用户空间的Poll注册的句柄。Registration实现了Evented,他不能用于系统事件中。<br>一个Registration总是会伴随一个SetReadiness，Registration用于注册到Poll中，调用poll方法后会阻塞，调用SetReadiness的set_readiness方法可以唤醒他。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-16-rust-fut01-md/",
            "url": "http://example.com/2018-11-16-rust-fut01-md/",
            "title": "rust future0.1",
            "date_published": "2018-11-16T10:21:23.000Z",
            "content_html": "<h2 id=\"Futures介绍\"><a href=\"#Futures介绍\" class=\"headerlink\" title=\"Futures介绍\"></a>Futures介绍</h2><p>在实际工作中，我们会遇到一些下面的场景：一次数据查询操作，一次向server端的RPC调用，一次timeout等待，一个运行在线程池中的耗时的任务，从socket读取数据等等。<br>我们要想取得运行计算的值，可以使用同步的方法等待返回值，但会遇到一些不便，如主线程不能太耗时，线程阻塞方案实现不方便等。当同步的方式不行时，我们可以考虑异步的方式实现，futures就是一种异步实现方式。具体上说就是future抽像了异步的函数，future的值就是任务的计算结果。</p>\n<p>整个Futures库分为五个大的模块，接下来会分别介绍：</p>\n<h3 id=\"Future-trait\"><a href=\"#Future-trait\" class=\"headerlink\" title=\"Future trait\"></a>Future trait</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Future</span></span> &#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span>;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Error</span></span>;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; Poll&lt;Self::Item, Self::Error&gt;;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">wait</span></span>(slef) -&gt; <span class=\"hljs-built_in\">Result</span>::<span class=\"hljs-built_in\">Result</span>&lt;Self::Item, Self::Error&gt; &#123;<br>        ...<br>    &#125;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从代码中可以看到他有两个类型Item和Error,Item就是Future结束时返回值的类型。最主要的是poll方法，使用者需要实现方法复写自己的逻辑，Future通过poll不断的查询返回结果。</p>\n<ol>\n<li>  poll方法</li>\n</ol>\n<pre><code>尝试获取结果，没有获取值是返回Ok(Async::NotReady),有返回值是返回Ok(Async::Ready(Item)),错误时返回Result::Error(err)。该函数不会阻塞当前线程。\n</code></pre>\n<ol start=\"2\">\n<li>wait方法<br> 该方法在任务完成前会阻塞当前线程，所以它不适合在event loops场景中调用。从源码分析得出的wait方法执行流程：</li>\n</ol>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coq\">graph TD<br>    A[wait] --&gt; B(Spawn::wait_future)<br>    B--&gt;C[Spawn::poll_future_notify]<br>    C--&gt;D&#123;返回结果&#125;<br>    D--&gt;|<span class=\"hljs-type\">Ready</span>| <span class=\"hljs-type\">D1</span>(<span class=\"hljs-keyword\">end</span>)<br>    D--&gt;|<span class=\"hljs-type\">NotReady</span>| <span class=\"hljs-type\">D2</span>[Notify.park]<br>    D2--&gt;|<span class=\"hljs-type\">外部调用notify</span>| <span class=\"hljs-type\">C</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/std/mod.rs.html#227-237\">wait源码</a>  <a href=\"https://docs.rs/crate/futures/0.1.25/source/src/task_impl/core.rs\">相关代码</a></p>\n<ol start=\"3\">\n<li>Future的转换方法<br> Future有许多的转换方法，功能都类似转换完后都会把自己消费掉，生成一个新的Future。<ul>\n<li>map</li>\n<li>map_err</li>\n<li>from_err</li>\n<li>then</li>\n<li>and_then</li>\n<li>or_else</li>\n<li>join</li>\n<li>select</li>\n<li>select2</li>\n<li>into_stream  转换成Stream</li>\n<li>flattern</li>\n<li>flatten_stream 转换成Stream</li>\n<li>fuse 完成状态后不可用的一种Future</li>\n<li>insepect 完成后会调用一个结果处理函数</li>\n<li>catch_unwind</li>\n<li>shared  多线程共享的</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Future的五种生成方式\"><a href=\"#Future的五种生成方式\" class=\"headerlink\" title=\"Future的五种生成方式\"></a>Future的五种生成方式</h3><ul>\n<li>impl <a href=\"https://docs.rs/futures/0.1.25/futures/future/trait.IntoFuture.html\">IntoFuture</a> trait，通过into_future 方法生成Future, Reuslt,(A:IntoFuture,B,C…)与实现了Future的struct默认实现了IntoFuture trait。</li>\n<li>impl <a href=\"https://docs.rs/futures/0.1.25/futures/future/trait.FutureFrom.html\">FutureFrom</a> trait,通过future_from方法生成Future。</li>\n<li>impl <a href=\"https://docs.rs/futures/0.1.25/futures/future/trait.Future.html\">Future</a> trait,写具体的poll方法。</li>\n<li>通过Future的转换方法生成，可转换成不同功能的Future。</li>\n<li>通过一些库自带的方法生成Future,比如，empty, lazy, loop_fn, poll_fn, select_all, select_ok, result, ok, join_all_err等。</li>\n</ul>\n<h2 id=\"Sink-trait\"><a href=\"#Sink-trait\" class=\"headerlink\" title=\"Sink trait\"></a>Sink trait</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Sink</span></span> &#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">SinkItem</span></span>;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">SinkError</span></span>;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">start_send</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, item: Self::SinkItem) -&gt; StartSend&lt;Self::SinkItem, Self::SinkError&gt;;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll_complete</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; Poll&lt;(), Self::SinkError&gt;;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">close</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; Poll&lt;(), Self::SinkError&gt; &#123;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Sink可以理解为数据消费者，从功能上来说只接收数据，当sink满时就不再接收数据了。比如Channels,Socket,Pipes等，从一定程度上来说buffer也可以算是Sink。</p>\n<h3 id=\"sink的方法\"><a href=\"#sink的方法\" class=\"headerlink\" title=\"sink的方法\"></a>sink的方法</h3><ol>\n<li> start_send   接收发送过来的数据，数据可处理时返回AsyncSink(Ready(Item)),不可时处理返回AsyncSink(NotReady)</li>\n<li> poll_complete  flush消费掉所有缓存的数据</li>\n<li> close,关闭该sink，不再处理数据，close之后不可以再调poll_complete。</li>\n<li> wait —&gt; <a href=\"https://docs.rs/futures/0.1.25/src/futures/sink/wait.rs.html#22-59\">Wait</a> 把异步的Sink转变成同步操作。</li>\n<li> with —&gt;With 处理数据时会执行一个函数</li>\n<li> with_flat_map –&gt;WithFlatMap,对每个value使用函数变成Stream,每个处理的数据为该Stream的整个值。</li>\n<li> buffer –&gt;<a href=\"https://docs.rs/futures/0.1.25/src/futures/sink/buffer.rs.html#12-18\">Buffer</a>，为sink做指定数量的缓存</li>\n<li> fanout –&gt; <a href=\"https://docs.rs/futures/0.1.25/futures/sink/struct.Fanout.html\">Fanout</a>,让两个处理速度不一样的Sink操持同步。</li>\n<li> flush  转变成一个Future,当Sink poll_complet完成时为完成状态</li>\n<li> send 转变成一个Future,发送一个value到sink中并阻塞直到sink flush完成</li>\n<li> send_all 如send,发送的是一个Stream</li>\n<li> 其他转换方法</li>\n</ol>\n<h3 id=\"Sink的生成方式\"><a href=\"#Sink的生成方式\" class=\"headerlink\" title=\"Sink的生成方式\"></a>Sink的生成方式</h3><ul>\n<li>默认实现的Sink，如Vec,Box<Sink></li>\n<li>impl Sink trait写start_send,poll_complete方法</li>\n<li>通过转换方法生成</li>\n</ul>\n<h2 id=\"stream-trait\"><a href=\"#stream-trait\" class=\"headerlink\" title=\"stream trait\"></a>stream trait</h2><p>Stream代表任何的数据源或一系列顺序事件，他的行为很像是Iterator,和Future一样他不会阻塞适合于异步编程</p>\n<h3 id=\"Stream-方法\"><a href=\"#Stream-方法\" class=\"headerlink\" title=\"Stream 方法\"></a>Stream 方法</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Stream</span></span> &#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Item</span></span>;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Error</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; Poll&lt;<span class=\"hljs-built_in\">Option</span>&lt;Self::Item&gt;, Self::Error&gt;;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>poll,尝试获取下一个值，如果Stream已结束返回None</li>\n<li>wait –&gt;Wait,创建一个迭代器，会阻塞当前线程直到Stream结束</li>\n<li>一些转换方法，较特殊的如collect方法生成<a href=\"https://docs.rs/futures/0.1.25/src/futures/stream/collect.rs.html#13-16\">Collect</a>把Stream中的值收集到一个Vector中，本身是一个Future；forward也是生成一个Future。</li>\n</ol>\n<h3 id=\"Stream的生成\"><a href=\"#Stream的生成\" class=\"headerlink\" title=\"Stream的生成\"></a>Stream的生成</h3><ol>\n<li>通过<a href=\"https://docs.rs/futures/0.1.25/futures/future/struct.IntoStream.html\">IntoStream</a> trait而来</li>\n<li>impl Stream trait写poll方法</li>\n<li>通过<a href=\"https://docs.rs/futures/0.1.25/futures/stream/index.html\">以下方法</a>生成：empty,futures_ordered,futures_unordered,iter,iter_ok,iter_result,once,poll_fn,repeat,unfold</li>\n<li>通过转换方法生成</li>\n</ol>\n<h2 id=\"Executor\"><a href=\"#Executor\" class=\"headerlink\" title=\"Executor\"></a>Executor</h2><p>Future代表了一个异步结果值，但开始并没有值，如何得到结果值呢。这就需要有一个机制去驱动他，这就是Executor的作用。通过executor调用Future去执行poll方法获取相应的值。但在futures这个库中只提供了相应的trait和简单的wait,notify实现。若想看线程池方案的executor实现可查点<a href=\"https://docs.rs/tokio/0.1.15/tokio/\">tokio库</a>。</p>\n<p>Sink与Stream最终都会转化为Future在Executor中执行。</p>\n<h3 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h3><p>一个重要的概念Task,它是一个轻量级的future的执行任务。通过<a href=\"https://docs.rs/futures/0.1.25/futures/task/fn.current.html\">current</a>函数获取当前future的Task</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><br><span class=\"hljs-meta\">#[derive(Clone)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Task</span></span> &#123;<br>    id: <span class=\"hljs-built_in\">usize</span>,<br>    unpark: TaskUnpark,<br>    events: UnparkEvents,<br>&#125;<br><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">TaskUnpark</span></span> &#123;<br>    handle: NotifyHandle,<br>    id: <span class=\"hljs-built_in\">usize</span>,<br>&#125;<br><br><span class=\"hljs-keyword\">impl</span> Task&#123;<br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">notify</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">self</span>.events.notify(); -&gt; no operation<br>        <span class=\"hljs-keyword\">self</span>.unpark.notify();-&gt;handle.notify(id)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"AtomicTask\"><a href=\"#AtomicTask\" class=\"headerlink\" title=\"AtomicTask\"></a><a href=\"https://docs.rs/futures/0.1.25/futures/task/struct.AtomicTask.html\">AtomicTask</a></h3><p>它的作用是作任务通知，当计算任务完成时通知代表其异步结果的Future。再这之前必须调用register注册Future的task，每个AtomicTask只能注册一个任务。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">AtomicTask</span></span> &#123;<br>    state: AtomicUsize,<br>    task: UnsafeCell&lt;<span class=\"hljs-built_in\">Option</span>&lt;Task&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Notify\"><a href=\"#Notify\" class=\"headerlink\" title=\"Notify\"></a>Notify</h3><p>   Noitfy是一个trait,用于通知executor执行future的poll方法。内部默认使用的<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/std/mod.rs.html#227-237\">ThreadNotify</a>实现。<br>   NotifyHandle是Notify的句柄，通过NotifyHandle可以在其他地方调用Notify的notify方法。</p>\n<h3 id=\"LocalKey\"><a href=\"#LocalKey\" class=\"headerlink\" title=\"LocalKey\"></a>LocalKey</h3><p>代表Task的本地变量，可通过<a href=\"https://docs.rs/futures/0.1.25/futures/macro.task_local.html\">task_local</a>生成</p>\n<h3 id=\"future的Wait代码分析\"><a href=\"#future的Wait代码分析\" class=\"headerlink\" title=\"future的Wait代码分析\"></a>future的Wait代码分析</h3><ol>\n<li>找到future的<a href=\"https://docs.rs/futures/0.1.25/src/futures/future/mod.rs.html#295-300\">wait</a>入口，内部调用了 <blockquote>\n<p>::executor::spawn(self).wait_future()</p>\n</blockquote>\n</li>\n<li>找到<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/mod.rs.html#254-260\">spawn</a>,里面生成了一个Spawn实例。<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">spawn</span></span>&lt;T&gt;(obj: T) -&gt; Spawn&lt;T&gt; &#123;<br>        Spawn &#123;<br>        id: fresh_task_id(),<br>        obj: obj,<br>        data: local_map(),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>找到Spawn的<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/std/mod.rs.html#227-237\">wait_future</a>方法:<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">wait_future</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">Result</span>&lt;F::Item, F::Error&gt; &#123;<br>        ThreadNotify::with_current(|notify| &#123;<br><br>            <span class=\"hljs-keyword\">loop</span> &#123;<br>                <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span>.poll_future_notify(notify, <span class=\"hljs-number\">0</span>)? &#123;<br>                    Async::NotReady =&gt; notify.park(),<br>                    Async::Ready(e) =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">Ok</span>(e),<br>                &#125;<br>            &#125;<br>        &#125;)<br>    &#125;<br><br></code></pre></td></tr></table></figure>\n往下找到475行<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\">thread_local! &#123;<br>    <span class=\"hljs-keyword\">static</span> CURRENT_THREAD_NOTIFY: Arc&lt;ThreadNotify&gt; = Arc::new(ThreadNotify &#123;<br>        state: AtomicUsize::new(IDLE),<br>        mutex: Mutex::new(()),<br>        condvar: Condvar::new(),<br>    &#125;);<br>&#125;<br>.....<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">with_current</span></span>&lt;F, R&gt;(f: F) -&gt; R<br>        <span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;Arc&lt;ThreadNotify&gt;) -&gt; R,<br>    &#123;<br>        CURRENT_THREAD_NOTIFY.with(|notify| f(notify))<br>    &#125;<br></code></pre></td></tr></table></figure>\n相当于直接调用了一个loop循环，内部调用了poll_future_notify方法，如果返回NotReady则调用<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/std/mod.rs.html#481-516\">park</a>,阻塞了当前线程：<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">fn park(&amp;<span class=\"hljs-built_in\">self</span>) &#123;<br>        <span class=\"hljs-params\">...</span>.<br>        <br>        <span class=\"hljs-keyword\">let</span> mut m = <span class=\"hljs-built_in\">self</span>.mutex.lock().unwrap();<br><br>     <span class=\"hljs-params\">...</span><span class=\"hljs-params\">...</span><br>        <span class=\"hljs-keyword\">loop</span> &#123;<br>            m = <span class=\"hljs-built_in\">self</span>.condvar.wait(m).unwrap();<br><br>     <span class=\"hljs-params\">...</span>..<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n进入<a href=\"https://docs.rs/futures/0.1.25/src/futures/task_impl/mod.rs.html#320-327\">poll_future_notify</a>方法:<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll_future_notify</span></span>&lt;N&gt;(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>,<br>                                notify: &amp;N,<br>                                id: <span class=\"hljs-built_in\">usize</span>) -&gt; Poll&lt;T::Item, T::Error&gt;<br>       <span class=\"hljs-keyword\">where</span> N: <span class=\"hljs-built_in\">Clone</span> + <span class=\"hljs-built_in\">Into</span>&lt;NotifyHandle&gt;,<br>             T: Future,<br>   &#123;<br>       <span class=\"hljs-keyword\">self</span>.poll_fn_notify(notify, id, |f| f.poll())<br>   &#125;<br></code></pre></td></tr></table></figure>\n进入poll_fn_notify</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">poll_fn_notify</span></span>&lt;N, F, R&gt;(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>,<br>                             notify: &amp;N,<br>                             id: <span class=\"hljs-built_in\">usize</span>,<br>                             f: F) -&gt; R<br>        <span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> T) -&gt; R,<br>              N: <span class=\"hljs-built_in\">Clone</span> + <span class=\"hljs-built_in\">Into</span>&lt;NotifyHandle&gt;,<br>    &#123;<br>        <span class=\"hljs-keyword\">let</span> mk = || notify.clone().into();<br>        <span class=\"hljs-keyword\">self</span>.enter(BorrowedUnpark::new(&amp;mk, id), f)<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>进入enter方法</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">enter</span></span>&lt;F, R&gt;(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, unpark: BorrowedUnpark, f: F) -&gt; R<br>        <span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>(&amp;<span class=\"hljs-keyword\">mut</span> T) -&gt; R<br>    &#123;<br>        <span class=\"hljs-keyword\">let</span> borrowed = BorrowedTask &#123;<br>            id: <span class=\"hljs-keyword\">self</span>.id,<br>            unpark: unpark,<br>            events: BorrowedEvents::new(),<br>            map: &amp;<span class=\"hljs-keyword\">self</span>.data,<br>        &#125;;<br>        <span class=\"hljs-keyword\">let</span> obj = &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.obj;<br>        set(&amp;borrowed, || f(obj))<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>进入<a href=\"https://docs.rs/crate/futures/0.1.25/source/src/task_impl/core.rs\">set</a>方法</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">set</span></span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>, F, R&gt;(task: &amp;BorrowedTask&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt;, f: F) -&gt; R<br>    <span class=\"hljs-keyword\">where</span> F: <span class=\"hljs-built_in\">FnOnce</span>() -&gt; R<br>&#123;<br>    <span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">match</span> SET.load(Relaxed) &#123;<br>        <span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">&quot;not initialized&quot;</span>),<br>        n =&gt; <span class=\"hljs-keyword\">unsafe</span> &#123; mem::transmute::&lt;<span class=\"hljs-built_in\">usize</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(*<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>)&gt;(n) &#125;,<br>    &#125;;<br><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Reset</span></span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span></span>(*<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>), *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>);<br><br>    <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-built_in\">Drop</span> <span class=\"hljs-keyword\">for</span> Reset &#123;<br>        <span class=\"hljs-meta\">#[inline]</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">drop</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) &#123;<br>            (<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>)(<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">let</span> _reset = Reset(set, get_ptr().unwrap());<br>    set(task <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> _ <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">u8</span>);<br>    f()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>简单调用了这个闭包，即future.poll()方法。</p>\n<p>到这里poll方法如果成功返回则就结束了，如果返回NotReady则阻塞住了，<em><strong>如何通知unpark呢？</strong></em></p>\n<p>我们注意到上面有个<a href=\"https://docs.rs/crate/futures/0.1.25/source/src/task_impl/core.rs\">BorrowedTask</a>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Copy, Clone)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">BorrowedUnpark</span></span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; &#123;<br>    f: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-built_in\">Fn</span>() -&gt; NotifyHandle,<br>    id: <span class=\"hljs-built_in\">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>有一个返回<a href=\"https://docs.rs/futures/0.1/src/futures/task_impl/mod.rs.html#630-632\">NotifyHandle</a>的变量，下面就用到了他进行通知unpark</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">impl</span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; BorrowedUnpark&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; &#123;<br>    <span class=\"hljs-meta\">#[inline]</span><br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(f: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-built_in\">Fn</span>() -&gt; NotifyHandle, id: <span class=\"hljs-built_in\">usize</span>) -&gt; BorrowedUnpark&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt; &#123;<br>        BorrowedUnpark &#123; f: f, id: id &#125;<br>    &#125;<br><br>    <span class=\"hljs-meta\">#[inline]</span><br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">to_owned</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; TaskUnpark &#123;<br>        <span class=\"hljs-keyword\">let</span> handle = (<span class=\"hljs-keyword\">self</span>.f)();<br>        <span class=\"hljs-keyword\">let</span> id = handle.clone_id(<span class=\"hljs-keyword\">self</span>.id);<br>        TaskUnpark &#123; handle: handle, id: id &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">impl</span> TaskUnpark &#123;<br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">notify</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) &#123;<br>        <span class=\"hljs-keyword\">self</span>.handle.notify(<span class=\"hljs-keyword\">self</span>.id);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">will_notify</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;BorrowedUnpark) -&gt; <span class=\"hljs-built_in\">bool</span> &#123;<br>        <span class=\"hljs-keyword\">self</span>.id == other.id &amp;&amp; <span class=\"hljs-keyword\">self</span>.handle.inner == (other.f)().inner<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>所以要想通知到他就需要拿到这个task。</p>\n<h2 id=\"sync-模块\"><a href=\"#sync-模块\" class=\"headerlink\" title=\"sync 模块\"></a>sync 模块</h2><p>这个模块主要是处理future,streams和sinks使用时的同步工具，与标准库不同他不会阻塞线程，是工作在task级别。</p>\n<h3 id=\"mpsc\"><a href=\"#mpsc\" class=\"headerlink\" title=\"mpsc\"></a>mpsc</h3><p> multi-producer,single-consumer模型，FIFO queue with back pressure。主要有Sender和Receiver两个角色，通过他们很好的处理了backPressure的问题。</p>\n<h3 id=\"Sender-and-Receiver\"><a href=\"#Sender-and-Receiver\" class=\"headerlink\" title=\"Sender and Receiver\"></a>Sender and Receiver</h3><p>本质上Sender是一个Sink,Receiver是一个Stream。可通过<a href=\"https://docs.rs/futures/0.1.25/futures/sync/mpsc/fn.channel.html\">channel</a>方法生成</p>\n<h4 id=\"source-code\"><a href=\"#source-code\" class=\"headerlink\" title=\"source code\"></a><a href=\"https://docs.rs/futures/0.1.25/src/futures/sync/mpsc/mod.rs.html#639-670\">source code</a></h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Sender</span></span>&lt;T&gt; &#123;<br>    <span class=\"hljs-comment\">// Channel state shared between the sender and receiver.</span><br>    inner: Arc&lt;Inner&lt;T&gt;&gt;,<br><br>    <span class=\"hljs-comment\">// Handle to the task that is blocked on this sender. This handle is sent</span><br>    <span class=\"hljs-comment\">// to the receiver half in order to be notified when the sender becomes</span><br>    <span class=\"hljs-comment\">// unblocked.</span><br>    sender_task: Arc&lt;Mutex&lt;SenderTask&gt;&gt;,<br><br>    <span class=\"hljs-comment\">// True if the sender might be blocked. This is an optimization to avoid</span><br>    <span class=\"hljs-comment\">// having to lock the mutex most of the time.</span><br>    maybe_parked: <span class=\"hljs-built_in\">bool</span>,<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Receiver</span></span>&lt;T&gt; &#123;<br>    inner: Arc&lt;Inner&lt;T&gt;&gt;,<br>&#125;<br><br><span class=\"hljs-meta\">#[derive(Debug)]</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Inner</span></span>&lt;T&gt; &#123;<br>    <span class=\"hljs-comment\">// Max buffer size of the channel. If `None` then the channel is unbounded.</span><br>    buffer: <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">usize</span>&gt;,<br><br>    <span class=\"hljs-comment\">// Internal channel state. Consists of the number of messages stored in the</span><br>    <span class=\"hljs-comment\">// channel as well as a flag signalling that the channel is closed.</span><br>    state: AtomicUsize,<br><br>    <span class=\"hljs-comment\">// Atomic, FIFO queue used to send messages to the receiver</span><br>    message_queue: Queue&lt;<span class=\"hljs-built_in\">Option</span>&lt;T&gt;&gt;,<br><br>    <span class=\"hljs-comment\">// Atomic, FIFO queue used to send parked task handles to the receiver.</span><br>    parked_queue: Queue&lt;Arc&lt;Mutex&lt;SenderTask&gt;&gt;&gt;,<br><br>    <span class=\"hljs-comment\">// Number of senders in existence</span><br>    num_senders: AtomicUsize,<br><br>    <span class=\"hljs-comment\">// Handle to the receiver&#x27;s task.</span><br>    recv_task: Mutex&lt;ReceiverTask&gt;,<br>&#125;<br><br><br></code></pre></td></tr></table></figure>\n<p>可以看出Sender与Receiver共享了Inner部分，inner中有两个队列，一个用于存储消息，一个用于存储阻塞的发送任务。</p>\n<h4 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h4><pre><code>The steps for sending a message are roughly:\n\n1. Increment the channel message count\n2. If the channel is at capacity, push the task handle onto the wait queue\n3. Push the message onto the message queue.\n\nThe steps for receiving a message are roughly:\n\n1. Pop a message from the message queue\n2. Pop a task handle from the wait queue\n3. Decrement the channel message count.\n</code></pre>\n<p>分析代码时可以以<a href=\"https://docs.rs/futures/0.1.25/src/futures/sync/mpsc/mod.rs.html#923-958\">Receiver的Stream trait中的poll方法</a>为入口，或者以  <a href=\"https://docs.rs/futures/0.1.25/src/futures/sync/mpsc/mod.rs.html#643-654\">Sender的Sink trait中的start_send方法</a>为入口</p>\n<h3 id=\"SpawnHandle\"><a href=\"#SpawnHandle\" class=\"headerlink\" title=\"SpawnHandle\"></a><a href=\"https://docs.rs/futures/0.1.25/futures/sync/mpsc/struct.SpawnHandle.html\">SpawnHandle</a></h3><p> 通过<a href=\"https://docs.rs/futures/0.1.25/futures/sync/mpsc/fn.spawn.html\">spawn 方法</a>可产生一个SpawnHandle，<br> 参数<a href=\"https://docs.rs/futures/0.1.25/futures/future/trait.Executor.html\">executor</a>为上面提到过的Executor没有具体实现。<br> SpawnHandle是一个Stream的代理,当被drop时，Stream就不再产生数据了</p>\n<h3 id=\"onshot\"><a href=\"#onshot\" class=\"headerlink\" title=\"onshot\"></a>onshot</h3><p> 与mpsc关不多，也分为Sender和Receiver两个角色。但是Sender和Receiver本质是一个Future。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-11-02-cell/",
            "url": "http://example.com/2018-11-02-cell/",
            "title": "rust cell 详解",
            "date_published": "2018-11-02T14:39:42.000Z",
            "content_html": "<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p><a href=\"https://doc.rust-lang.org/std/cell/index.html\">https://doc.rust-lang.org/std/cell/index.html</a></p>\n<p>众所周知，rust的内存安全是基于一个规则，一个对像须满足以下规则：</p>\n<ul>\n<li>只存在一个可变引用</li>\n<li>有多个不可变引用</li>\n</ul>\n<p>在写rust代码时，会发现这样的规则在写代码时会受到一定的束缚。于是rust官方出了一个可以灵活解决对像可变性问题的工具cell。</p>\n<h2 id=\"cell与Mutex等的不同\"><a href=\"#cell与Mutex等的不同\" class=\"headerlink\" title=\"cell与Mutex等的不同\"></a>cell与Mutex等的不同</h2><p>诚然我们可以用Mutex, atomic等来解决可变性问题，但cell与mutex有本质的不同。<br>cell是线程安全的（没有实现Sync，不能跨线程访问），Mutex主要用来解决多线程数据竞争的。</p>\n<h2 id=\"cell的具体分析\"><a href=\"#cell的具体分析\" class=\"headerlink\" title=\"cell的具体分析\"></a>cell的具体分析</h2><p>cell的实现分Cell, RefCell, UnsafeCell，还有一个开源实现LazyCell</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-meta\">#[repr(transparent)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Cell</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; &#123;<br>    value: UnsafeCell&lt;T&gt;,<br>&#125;<br><br><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RefCell</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; &#123;<br>    borrow: Cell&lt;BorrowFlag&gt;,<br>    value: UnsafeCell&lt;T&gt;,<br>&#125;<br><br><br><span class=\"hljs-meta\">#[repr(transparent)]</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">UnsafeCell</span></span>&lt;T: ?<span class=\"hljs-built_in\">Sized</span>&gt; &#123;<br>    value: T,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>从源码上来看Cell和RefCell的内部都是由UnsafeCell来实现的, 要想理解Cell与RefCell就需要先了解UnsafeCell</p>\n<h3 id=\"UnsafeCell\"><a href=\"#UnsafeCell\" class=\"headerlink\" title=\"UnsafeCell\"></a>UnsafeCell</h3><p>UnsafeCell非常简单，有一个重要的方法：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-comment\">//返回一个可变指针</span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; *<span class=\"hljs-keyword\">mut</span> T &#123;<br>        <span class=\"hljs-keyword\">self</span> <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> UnsafeCell&lt;T&gt; <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">const</span> T <span class=\"hljs-keyword\">as</span> *<span class=\"hljs-keyword\">mut</span> T<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>通过一个不可变对像返回一个可变的对像指针，Cell与RefCell正是利用了这个达到相应的目的，前提是他们是线程安全的。</p>\n<h3 id=\"Cell\"><a href=\"#Cell\" class=\"headerlink\" title=\"Cell\"></a>Cell</h3><p>看一下replace,get, set, take等方法，都是基于UnsafeCell返回的可变指针的内存操作</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">replace</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, val: T) -&gt; T &#123;<br>        <span class=\"hljs-comment\">// SAFETY: This can cause data races if called from a separate thread,</span><br>        <span class=\"hljs-comment\">// but `Cell` is `!Sync` so this won&#x27;t happen.</span><br>        mem::replace(<span class=\"hljs-keyword\">unsafe</span> &#123; &amp;<span class=\"hljs-keyword\">mut</span> *<span class=\"hljs-keyword\">self</span>.value.get() &#125;, val)<br>    &#125;<br><span class=\"hljs-comment\">//T: Copy    </span><br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; T &#123;<br>        <span class=\"hljs-comment\">// SAFETY: This can cause data races if called from a separate thread,</span><br>        <span class=\"hljs-comment\">// but `Cell` is `!Sync` so this won&#x27;t happen.</span><br>        <span class=\"hljs-keyword\">unsafe</span> &#123; *<span class=\"hljs-keyword\">self</span>.value.get() &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"RefCell\"><a href=\"#RefCell\" class=\"headerlink\" title=\"RefCell\"></a>RefCell</h3><p>Refcell是在Cell的增强版，他在Cell的基础上添加了借用，内部维护着一个借用的标识，在运行时做借用检查。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">borrow</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; Ref&lt;<span class=\"hljs-symbol\">&#x27;_</span>, T&gt; &#123;<br>        <span class=\"hljs-keyword\">self</span>.try_borrow().expect(<span class=\"hljs-string\">&quot;already mutably borrowed&quot;</span>)<br>    &#125;<br>    <br><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">borrow_mut</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; RefMut&lt;<span class=\"hljs-symbol\">&#x27;_</span>, T&gt; &#123;<br>        <span class=\"hljs-keyword\">self</span>.try_borrow_mut().expect(<span class=\"hljs-string\">&quot;already borrowed&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>主要方法borrow和borrow_mut返回相应的引用对像，当Ref或RefMut销毁时相应的借用关系消除</p>\n<h3 id=\"LazyCell\"><a href=\"#LazyCell\" class=\"headerlink\" title=\"LazyCell\"></a>LazyCell</h3><p><a href=\"https://github.com/indiv0/lazycell\">https://github.com/indiv0/lazycell</a>, 从代码看其和Cell功能类似，用于延迟初始化。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">LazyCell</span></span>&lt;T&gt; &#123;<br>    inner: UnsafeCell&lt;<span class=\"hljs-built_in\">Option</span>&lt;T&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-2-11-daemon-thread/",
            "url": "http://example.com/2018-2-11-daemon-thread/",
            "title": "java守护线程",
            "date_published": "2018-02-11T05:06:28.000Z",
            "content_html": "<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>线程分为前台线程（用户线程）与后台线程（守护线程），守护线程并不常用，他主要为其他对像或用户线程提供服务。一般的守护线程如   jvm垃圾回收线程，和内存管理线程等。<br>守护线程具有最低的优先级，他不依赖于终端，但依赖于虚拟机。 而jvm的退出是以用户线程的运行结束为终止的。</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\"><span class=\"hljs-keyword\">Thread</span> th = <span class=\"hljs-literal\">new</span> <span class=\"hljs-keyword\">Thread</span>();<br>th.setDaemon(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">//设置为守护线程</span><br></code></pre></td></tr></table></figure>\n<p>setDaemon方法必须要在start方法之前调，否则会产生illegalThreadStateException;</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>对于jre来说程序的运行结束的标志是所有前台线程的运行结束，而不管守护线程是否运行完。</p>\n<p>当前台线程运行完成时，程序就自动终止了，因此不要在守护线程中做文件，输入输出等操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>    Thread daemon_th =  <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;daemon thread start&quot;</span>);<br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                Thread.sleep(<span class=\"hljs-number\">1000</span>);<br>            &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class=\"hljs-string\">&quot;daemon thread finished&quot;</span>);<br>        &#125;<br>    &#125;);<br>    daemon_th.setDaemon(<span class=\"hljs-keyword\">true</span>);<br>    Thread work_th =  <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;work thread finished&quot;</span>);<br>        &#125;<br>    &#125;);<br>    daemon_th.start();<br>    work_th.start();<br>    System.out.println(<span class=\"hljs-string\">&quot;main thread finished&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>运行结果为:<br>daemon thread start<br>work thread finished<br>main thread finished</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>由于以上的特点，守护线程不适合做资源申请回收相关的操作。适合做为其他线程服务的工作。</p>\n<p>如java的垃圾回收线程就是典型的守护线程。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2018-01-11-jnr/",
            "url": "http://example.com/2018-01-11-jnr/",
            "title": "jni与jnr",
            "date_published": "2018-01-11T13:48:26.000Z",
            "content_html": "<h3 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h3><p>在熟悉了JNI使用及其原理后，发现在JNI有一些缺点：</p>\n<ul>\n<li>对新手不够友好，上手成本相当的高</li>\n<li>需要熟悉c/c++等native语言</li>\n<li>对接过程比较复杂</li>\n</ul>\n<p>对于熟悉JNI的工程师来说，可以驾轻就熟的写出如下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JNITest</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>       <span class=\"hljs-keyword\">try</span> &#123;<br>            System.loadLibrary(<span class=\"hljs-string\">&quot;libXXX&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">catch</span>(Exception e) &#123;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">native</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br><br><span class=\"hljs-function\">JNIEXPORT jstring <span class=\"hljs-title\">Java_JNITest_test</span><span class=\"hljs-params\">(JNIEnv*, jclass)</span></span>;<br></code></pre></td></tr></table></figure>\n<p>写惯了这样的对接代码后发现一个问题: java代码与jni native接口似乎是可以自动映射的，包括参数，函数名。如果在jni胶水层不需要写其他逻辑代码的话，就是一个简单的本地调用再封装。</p>\n<p>这些千篇一律的代码，可不可以标准化呢？有两种比较好的解决方案:</p>\n<ul>\n<li><a href=\"https://github.com/java-native-access/jna\">JNA(Java Native Access)</a></li>\n<li><a href=\"https://github.com/jnr\">JNR(Java Native Runtime)</a></li>\n</ul>\n<p><a href=\"https://www.oracle.com/technetwork/java/jvmls2013nutter-2013526.pdf\">这篇文章</a>很好的讲述了他们的之间的区别，不过文章比较老了，随着时间的流逝，技术在不断的更新升级。成熟的方案意是会受到用户的青睐。</p>\n<h3 id=\"JNA-JNR\"><a href=\"#JNA-JNR\" class=\"headerlink\" title=\"JNA/JNR\"></a>JNA/JNR</h3><p>这两种解决方案都不需要写jni代码，集成起来相当的方便</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JNATest</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CLibrary</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">Library</span> &#123;<br>        CLibrary INSTANCE = (CLibrary)Native.loadLibrary(<span class=\"hljs-string\">&quot;CDLL&quot;</span>, CLibrary.<span class=\"hljs-keyword\">class</span>);<br><br>        <span class=\"hljs-function\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> a, <span class=\"hljs-built_in\">int</span> b</span>)</span>;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>)</span> &#123;<br>        <span class=\"hljs-built_in\">int</span> sum = CLibrary.INSTANCE.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>);<br><br>        System.<span class=\"hljs-keyword\">out</span>.println(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><ul>\n<li>类型映射</li>\n<li>JNI Stub</li>\n<li><a href=\"https://asm.ow2.io/\">字节码生成</a></li>\n</ul>\n<h3 id=\"与JNI的区别\"><a href=\"#与JNI的区别\" class=\"headerlink\" title=\"与JNI的区别\"></a>与JNI的区别</h3><ul>\n<li>JNI是JNA/JNR的基础</li>\n<li>JNA/JNR不可能取代JNI， 适用于Java调用native的场景</li>\n<li>native调用java代码，还是要借用jni,自己写代码</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2017-08-17-jni/",
            "url": "http://example.com/2017-08-17-jni/",
            "title": "jni实践总结",
            "date_published": "2017-08-17T11:45:53.000Z",
            "content_html": "<h3 id=\"JNI介绍\"><a href=\"#JNI介绍\" class=\"headerlink\" title=\"JNI介绍\"></a>JNI介绍</h3><p>JNI (java native interface), 是java与native语言(c/c++, rust等)之间的胶水， 用于解决java与native之间相互调用的问题。</p>\n<h3 id=\"JNI-Function与指针\"><a href=\"#JNI-Function与指针\" class=\"headerlink\" title=\"JNI Function与指针\"></a>JNI Function与指针</h3><p>native代码在访问JVM相关的信息时所使用的函数叫JNI函数。JNI函数只能通过JNI指针调用。</p>\n<p><img src=\"https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/images/designa.gif\" alt=\"image\"></p>\n<p>JNI接口的组织形式和C++的函数表非常相似。这样设计的主要优势是JNI的名字空间可以与native分开。JVM可以很容易的保有多个版本的JNI函数表。</p>\n<p>注意JNIEnv是线程本地变量，不可跨线程使用</p>\n<h3 id=\"加载动态库与方法映射\"><a href=\"#加载动态库与方法映射\" class=\"headerlink\" title=\"加载动态库与方法映射\"></a>加载动态库与方法映射</h3><p>java加载动态库</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.juzenhon.jni;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> &#123;<br>        System.loadLibrary(“libXXX”);<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">native</span> staic <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>)</span></span>;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">native</span> String <span class=\"hljs-title\">getStr</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>jni层想关方法</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//加载动动态库时回调</span><br>JNIEXPORT jint JNICALL <span class=\"hljs-constructor\">JNI_OnLoad(JavaVM <span class=\"hljs-operator\">*</span><span class=\"hljs-params\">vm</span>, <span class=\"hljs-params\">void</span> <span class=\"hljs-operator\">*</span><span class=\"hljs-params\">reserved</span>)</span>;<br><span class=\"hljs-comment\">//卸载动态库时回调</span><br>JNIEXPORT void JNICALL <span class=\"hljs-constructor\">JNI_OnUnload(JavaVM <span class=\"hljs-operator\">*</span><span class=\"hljs-params\">vm</span>, <span class=\"hljs-params\">void</span> <span class=\"hljs-operator\">*</span><span class=\"hljs-params\">reserved</span>)</span>;<br><br><span class=\"hljs-comment\">//add方法在jni中的映射</span><br>JNIEXPORT jint <span class=\"hljs-constructor\">Java_com_juzenhon_jni_Test_add(JNIEnv<span class=\"hljs-operator\">*</span>, <span class=\"hljs-params\">jclass</span>, <span class=\"hljs-params\">jint</span>, <span class=\"hljs-params\">jint</span>)</span>;<br><br><span class=\"hljs-comment\">//getStr方法在jni中的映射</span><br>JNIEXPORT jstring <span class=\"hljs-constructor\">Java_com_juzenhon_jni_Test_getStr(JNIEnv<span class=\"hljs-operator\">*</span>, <span class=\"hljs-params\">jobject</span>)</span>;<br><br><span class=\"hljs-comment\">//除了上面这种通过Java_包名_类名_方法名的映射形式，还可以通过该函数注册本地方法关联映射</span><br><span class=\"hljs-constructor\">RegisterNatives()</span> <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"native方法参数-jni类型\"><a href=\"#native方法参数-jni类型\" class=\"headerlink\" title=\"native方法参数, jni类型\"></a>native方法参数, jni类型</h3><p>所有java native的第一个参数是JNI接口指针(也就是JNIEnv), 第二个参数依赖于该native方法是否是静态的，非静态的是object的引用 （jobject), 静态的是jclass。其余的是相对应的java参数(对应关系可以在<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/types.html\">这里找</a>)。</p>\n<p>java与jni类型基本上一一对应，基本数据类型是值传递，对像使用jobject指针传递，自己做对象映射。<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/types.html\">详细类型链接</a></p>\n<h3 id=\"JNI-References\"><a href=\"#JNI-References\" class=\"headerlink\" title=\"JNI References\"></a>JNI References</h3><p>JNI中把对java对像的引用分为 local-Reference 和 global-Reference两种。</p>\n<ul>\n<li>local Reference不能跨线程访问传递，只有等到native方法返回后才会一起销毁。jvm维护了一个local reference表，有大小限制，典型值是512。在使用中避免传递过大的对多的对像，如对一大的对像List进行循环迭代而忘了手动释放产生的loal reference。</li>\n<li>global reference 可跨线程访问，不用时通过DeleteGlobalReference删除</li>\n<li>两种引用都会影响JVM对其Java对像的回收</li>\n</ul>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><ul>\n<li>JNI可以抛出Java异常</li>\n<li>在JNI回调Java代码后。native并不能捕获java异常，须通过ExceptionOccurred 检查是否有异常发生，native可通过ExceptionClear清除异常，然后执行自己的异常处理过程。</li>\n</ul>\n<h3 id=\"数据缓存\"><a href=\"#数据缓存\" class=\"headerlink\" title=\"数据缓存\"></a>数据缓存</h3><p>为了提高效率，JNI中jclass，jmethod, jfield等可以只查询一次并缓存起来供下次直接使用。</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><ul>\n<li><p>在native中新开线程并想访问Java代码时， 需要先把Attach到JVM, 使用完毕后Detach。Attach后可获取到JNIEnv</p>\n</li>\n<li><p>可通过MonitorEnter和MonitorExit实现java的Synchronize</p>\n</li>\n<li><h3 id=\"大数据的传递\"><a href=\"#大数据的传递\" class=\"headerlink\" title=\"大数据的传递\"></a>大数据的传递</h3><p>在java与native之间传递数据时，需要做相应的对像内存转换，如，把c++的map转换成java的Map。如果数据量较大时，效率是比较低的。一般有以下几种解决方式</p>\n</li>\n<li><p>java NIO 使用了直接内存访问的形式, DirectByteBuffer（堆外内存)。jni给与了支持，NewDirectByteBuffer方法</p>\n</li>\n<li><p>不做数据转换，传一个内存指针上去，（缺点不好维护，有可能导致内存泄漏</p>\n</li>\n<li><p>拆封或调整接口，数据细粒度化</p>\n</li>\n<li><p>懒加载模式， 根据上层使用的数据情况做转换</p>\n</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2015-08-11-android-cmd-md/",
            "url": "http://example.com/2015-08-11-android-cmd-md/",
            "title": "android adb 命令",
            "date_published": "2015-08-11T05:19:26.000Z",
            "content_html": "<h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>在android开发过程中，避免不了在要与机器或虚拟机打交道，为了方便调试，我们需要了解一些有用的命令。</p>\n<h4 id=\"adb-shell-dumpsys\"><a href=\"#adb-shell-dumpsys\" class=\"headerlink\" title=\"adb shell dumpsys\"></a>adb shell dumpsys</h4><pre><code>    usage: dumpsys\n      To dump all services.\nor:\n   dumpsys [-t TIMEOUT] [--help | -l | --skip SERVICES | SERVICE [ARGS]]\n     --help: shows this help\n     -l: only list services, do not dump them\n     -t TIMEOUT: TIMEOUT to use in seconds instead of default 10 seconds\n     --skip SERVICES: dumps all services but SERVICES (comma-separated list)\n     SERVICE [ARGS]: dumps only service SERVICE, optionally passing ARGS to it\n\nSERVICE主要为：\n    dumpsys -l //可列出所有的SERVICE值\n    meminfo //显示内存信息\n    activity //显示activitiy信息（ ARGS 主要为activities,intents,services,providers等)\n    cpuinfo //显示CPU信息\n    package packagename //获取安装包信息\n    batterystats  //显示电量信息\n    window //显示键盘，窗口和它们的关系（dumpsys window lastanr)\n</code></pre>\n<h4 id=\"adb-shell-am\"><a href=\"#adb-shell-am\" class=\"headerlink\" title=\"adb shell am\"></a>adb shell am</h4><pre><code>    am start -a android.intent.action.VIEW -d http://www.google.cn/\n    am start -n com.xxx.yyy/XActivity\n    startservice\n    startactivity\n    stopservice\n    broadcast  -a android.NET.conn.CONNECTIVITY_CHANGE\n    ……\n    stack list //堆栈信息\n    monitor //监控crash or ANR\n    \n</code></pre>\n<h4 id=\"adb-shell-pm\"><a href=\"#adb-shell-pm\" class=\"headerlink\" title=\"adb shell pm\"></a>adb shell pm</h4><pre><code>    help\n    list （features | packages | libraries |  instrumentation | permissions | permission-groups）\n    resolve-activity\n    query-activities\n    query-services\n    suspend\n    query-receivers\n    clear com.xxx.xxx\n</code></pre>\n<h4 id=\"让需要输入内容的文本框获取焦点\"><a href=\"#让需要输入内容的文本框获取焦点\" class=\"headerlink\" title=\"让需要输入内容的文本框获取焦点\"></a>让需要输入内容的文本框获取焦点</h4><p>adb shell input text ‘HelloWorld’</p>\n<h4 id=\"查看设备中可以被调试的应用的进程号\"><a href=\"#查看设备中可以被调试的应用的进程号\" class=\"headerlink\" title=\"查看设备中可以被调试的应用的进程号\"></a>查看设备中可以被调试的应用的进程号</h4><p>adb jdwp</p>\n<h4 id=\"查看设备的-ip-地址\"><a href=\"#查看设备的-ip-地址\" class=\"headerlink\" title=\"查看设备的 ip 地址\"></a>查看设备的 ip 地址</h4><p>netcfg</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2013-12-24-android-touch/",
            "url": "http://example.com/2013-12-24-android-touch/",
            "title": "android touch处理流程",
            "date_published": "2013-12-24T02:58:45.000Z",
            "content_html": "<h3 id=\"Touch-事件简介\"><a href=\"#Touch-事件简介\" class=\"headerlink\" title=\"Touch 事件简介\"></a>Touch 事件简介</h3><p>在android进行ui交互时，不可避免的要涉及到touch事件，如onClick，onLongClick ,onItemClick等等事件都是经过一连串的touch形成的。</p>\n<p>MotionEvent分为以下几个动作：<br>MotionEvent.ACTION_DOWN——–第一个手指按下的动作<br>MotionEvent.ACTION_MOVE ——–按下后的移动操作<br>MotionEvent.ACTION_POINTER_DOWN ——-第二根及以上的手指按下<br>MotionEvent.ACTION_POINTER_UP  ——–<br>MotionEvent.ACTION_UP ———–手指抬起操作，表示一次触摸操作完成<br>MotionEvent.ACTION_CANCEL     ———-DOWN目标的取消动作</p>\n<h3 id=\"Touch-事件流程\"><a href=\"#Touch-事件流程\" class=\"headerlink\" title=\"Touch 事件流程\"></a>Touch 事件流程</h3><ul>\n<li> 按照Touch的发生顺序，首先是Down事件，而Down事件的处理有决定作用，下图为down事件的处理：</li>\n</ul>\n<p><img src=\"/images/touchdown.png\"></p>\n<ul>\n<li>move和up的事件处理</li>\n</ul>\n<p>上图中的TouchTarget我们称之为处理目标，下图为move和up事件的处理过程：</p>\n<p><img src=\"/images/touchother.bmp\"></p>\n",
            "tags": []
        }
    ]
}


<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="朱新宏的博客">
  <meta name="author" content="zhuxinhong">
  <meta name="keywords" content="">
  
  <title>tokio0.1分析 - 黑色红桃7</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"0451f73cbd5a12ac989afc39ee0d08e7","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":1279826644,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="黑色红桃7" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="tokio0.1分析">
              
                tokio0.1分析
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-11-20 19:28" pubdate>
        2018年11月20日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      54
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">tokio0.1分析</h1>
            
            <div class="markdown-body">
              <h1 id="关于-tokio"><a href="#关于-tokio" class="headerlink" title="关于 tokio"></a>关于 tokio</h1><h2 id="what-is-tokio"><a href="#what-is-tokio" class="headerlink" title="what is tokio"></a>what is tokio</h2><p>tokio是一个rust语言的异步编程框架，是一个基于事件驱动和非阻塞I/O的框架。在上层设计上，它提供了一些主要组件：</p>
<ul>
<li>多线程，任务窃取(work-stealing)的task <a target="_blank" rel="noopener" href="https://tokio-rs.github.io/tokio/tokio/runtime/index.html">scheduler</a> (runtime)</li>
<li>由操作系统的事件队列（epoll,kqueue,IOCP等）支撑的<a target="_blank" rel="noopener" href="https://docs.rs/tokio/0.1.1/tokio/reactor/index.html">reactor</a></li>
<li>异步<a target="_blank" rel="noopener" href="https://docs.rs/tokio/0.1/tokio/net/index.html">TCP和UDP</a>套接字</li>
</ul>
<h2 id="tokio-优势"><a href="#tokio-优势" class="headerlink" title="tokio 优势"></a>tokio 优势</h2><ul>
<li>零成本抽象，tokio是基于futures的。</li>
<li>并发，tokio提供了多线程，work-stealing,scheduler。在现代多核cpu的情况下你可以充分利用他们提高应用的性能。</li>
<li>非阻塞，高性能，当涉及到网络时，tokio会非常有效的使用系统，如linux上的<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a>,bsd平台的<a target="_blank" rel="noopener" href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2">kqueue</a>,Windows的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/fileio/i-o-completion-ports">I/O completion ports</a>,他们可以在单线程中进行多路复用，批量接收系统通知，减少系统调用。<blockquote>
<p> Because Tokio uses a poll based model, the problem mostly just goes away. Producers are lazy by default. They will not produce any data unless the consumer asks them to. This is built into Tokio’s foundation.</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>Reliable，api清晰易用，使用rust不会有太多的内存问题。</p>
</li>
<li><p>BackPressure，在基于push的系统中，当生产者生产数据的速度超过了消费者消费的速度，数据就会暂存在内存中。除非生产者停止生产，否则系统就会因为内存耗尽而崩溃。消费者通知生产者放慢生产的能力就是BackPressure。在tokio中利用<a target="_blank" rel="noopener" href="https://tokio.rs/docs/getting-started/futures/#poll-based-futures">poll</a>的方式很好的解决了这个问题。</p>
</li>
<li><p>Cancellation</p>
<blockquote>
<p>Because of Tokio’s poll based model, computations do no work unless they are polled. Dependents of that computation hold a future representing the result of that computation. If the result is no longer needed, the future is dropped. At this point, the computation will no longer be polled and thus perform no more work.</p>
</blockquote>
<blockquote>
<p>Thanks to Rust’s ownership model, the computation is able to implement drop handles to detect the future being dropped. This allows it to perform any necessary cleanup work.</p>
</blockquote>
</li>
<li><p>轻量级框架</p>
</li>
<li><p>没有垃圾回收</p>
</li>
</ul>
<h2 id="tokio的结构"><a href="#tokio的结构" class="headerlink" title="tokio的结构"></a>tokio的结构</h2><p>结构总体抽象为Futures,Tasks和Executor,并提供了提供了Timer等基础设施。tokio快速，可靠，且可扩展。<br>Tokio 是一个事件驱动的非阻塞I/O框架，用于rust编程语言编写异步应用。在高层设计上，这些组件提供了很好的抽象，大大简化了编码工作。</p>
<h3 id="tokio的依赖"><a href="#tokio的依赖" class="headerlink" title="tokio的依赖"></a>tokio的依赖</h3><p>tokio主要的依赖有futures,mio(基于异步事件通知的高性能I/O库)</p>
<h4 id="mio"><a href="#mio" class="headerlink" title="mio"></a>mio</h4><p>参见mio模块</p>
<h4 id="future"><a href="#future" class="headerlink" title="future"></a>future</h4><p>参见future模块</p>
<h3 id="tokio分析"><a href="#tokio分析" class="headerlink" title="tokio分析"></a>tokio分析</h3><p>tokio主要分clock,codec,executor,fs,io,net,reactor,runtime,timer这几个模块。这里挑几个主要介绍。</p>
<h4 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h4><p>executor的作用是执行任务。在tokio执行模型中，futures是懒模式，也就是说当一个future被创建时是不会执行的，为了让他工作，我们要把化丢到一个executor里。在executor里的future就叫做task。<br>当task被通知时，exectuor确保future的poll方法会被执行。executor一般有有两种模型，单线程和多线程，在runtime模块中都有实现。</p>
<h5 id="DefaultExecutor"><a href="#DefaultExecutor" class="headerlink" title="DefaultExecutor"></a>DefaultExecutor</h5><p><a target="_blank" rel="noopener" href="https://docs.rs/tokio-executor/0.1.5/src/tokio_executor/global.rs.html#18-20">DefaultExecutor</a>实现了<a target="_blank" rel="noopener" href="https://docs.rs/tokio/0.1/tokio/executor/trait.Executor.html">tokio::executor::Executor</a>,同样也实现了future的Executor trait这样就可以和futures库联系起来。<br>我们来分析一下他的源码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DefaultExecutor</span></span> &#123;<br>    _dummy: (),<br>&#125;<br><br><span class="hljs-keyword">impl</span> DefaultExecutor &#123;<br>   <br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">current</span></span>() -&gt; DefaultExecutor &#123;<br>        DefaultExecutor &#123;<br>            _dummy: (),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">#[inline]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with_current</span></span>&lt;F: <span class="hljs-built_in">FnOnce</span>(&amp;<span class="hljs-keyword">mut</span> Executor) -&gt; R, R&gt;(f: F) -&gt; <span class="hljs-built_in">Option</span>&lt;R&gt; &#123;<br>        EXECUTOR.with(|current_executor| &#123;<br>            <span class="hljs-keyword">match</span> current_executor.replace(State::Active) &#123;<br>                State::Ready(executor_ptr) =&gt; &#123;<br>                    <span class="hljs-keyword">let</span> executor = <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> *executor_ptr &#125;;<br>                    <span class="hljs-keyword">let</span> result = f(executor);<br>                    current_executor.set(State::Ready(executor_ptr));<br>                    <span class="hljs-literal">Some</span>(result)<br>                &#125;,<br>                State::Empty | State::Active =&gt; <span class="hljs-literal">None</span>,<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone, Copy)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span></span> &#123;<br>    <span class="hljs-comment">// default executor not defined</span><br>    Empty,<br>    <span class="hljs-comment">// default executor is defined and ready to be used</span><br>    Ready(*<span class="hljs-keyword">mut</span> Executor),<br>    <span class="hljs-comment">// default executor is currently active (used to detect recursive calls)</span><br>    Active<br>&#125;<br><br><span class="hljs-comment">/// Thread-local tracking the current executor</span><br>thread_local!(<span class="hljs-keyword">static</span> EXECUTOR: Cell&lt;State&gt; = Cell::new(State::Empty));<br></code></pre></td></tr></table></figure>

<p>从源码看DefaultExecutor并没有具体的实现，只是一个空壳。每个线程都有一个指针指向一个设置的Executor，使用的是线程本地变量保存。</p>
<p><em><strong>那么如何设置该Executor呢？</strong></em></p>
<p>使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio-executor/0.1.5/src/tokio_executor/global.rs.html#158-194">with_default</a>方法，他有一个<a target="_blank" rel="noopener" href="https://docs.rs/crate/tokio-executor/0.1.5/source/src/enter.rs">Enter</a>类型的变量，代表的是executor的上下文</p>
<h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p>reactor主要用来管理Event loop,reactor用来接收从操作系统的事件(epoll,kqueue,IOCP,…),然后转发给等待的tasks。reactor可以看做是操作系统与futures模型之间的桥梁。<br>reactor从操作系统接收事件后会通知到executor。</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> tokio::prelude::*;<br><span class="hljs-keyword">use</span> tokio::net::TcpStream;<br><br><span class="hljs-keyword">let</span> addr = <span class="hljs-string">&quot;93.184.216.34:9243&quot;</span>.parse().unwrap();<br><br><span class="hljs-keyword">let</span> connect_future = TcpStream::connect(&amp;addr);<br><br><span class="hljs-keyword">let</span> task = connect_future<br>    .and_then(|socket| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;successfully connected&quot;</span>);<br>        <span class="hljs-literal">Ok</span>(())<br>    &#125;)<br>    .map_err(|e| <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;failed to connect; err=&#123;:?&#125;&quot;</span>, e));<br><br>tokio::run(task);<br></code></pre></td></tr></table></figure>
<p>调用connect方法后，会立即返回一个ConnectFuture，并不会阻塞当前线程。<br>run方法执行后，会把task放到threadpool中，task会执行一次返回NotReady,此时会放回threadpool等待通知再次执行。<br>当tcp连接建立后，reactor会从操作系统收到相应的事件，并通知threadpool task可以再次执行。</p>
<p>以上代码并没有涉及到Reactor，是因为他包装在了run方法内，我们稍后分析。</p>
<h3 id="reactor源码分析"><a href="#reactor源码分析" class="headerlink" title="reactor源码分析"></a><a target="_blank" rel="noopener" href="https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/lib.rs.html#88-96">reactor源码分析</a></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Reactor</span></span> &#123;<br>    <span class="hljs-comment">/// Reuse the `mio::Events` value across calls to poll.</span><br>    events: mio::Events,<br><br>    <span class="hljs-comment">/// State shared between the reactor and the handles.</span><br>    inner: Arc&lt;Inner&gt;,<br><br>    _wakeup_registration: mio::Registration,<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inner</span></span> &#123;<br>    <span class="hljs-comment">/// The underlying system event queue.</span><br>    io: mio::Poll,<br><br>    <span class="hljs-comment">/// ABA guard counter</span><br>    next_aba_guard: AtomicUsize,<br><br>    <span class="hljs-comment">/// Dispatch slabs for I/O and futures events</span><br>    io_dispatch: RwLock&lt;Slab&lt;ScheduledIo&gt;&gt;,<br><br>    <span class="hljs-comment">/// Used to wake up the reactor from a call to `turn`</span><br>    wakeup: mio::SetReadiness<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ScheduledIo</span></span> &#123;<br>    aba_guard: <span class="hljs-built_in">usize</span>,<br>    readiness: AtomicUsize,<br>    reader: AtomicTask,<br>    writer: AtomicTask,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们看到了熟悉的东西，mio::Events和mio::Poll这两个。<br>Reactor中有几个主要的方法：</p>
<ol>
<li>handle –&gt; Handle 返回该Reactor的一个句柄<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#[derive(Clone)]</span><br>struct <span class="hljs-class">HandlePriv </span>&#123;<br><span class="hljs-symbol">    inner:</span> Weak<span class="hljs-params">&lt;Inner&gt;</span>,<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li>set_fallback</li>
<li>turn<br> 从源码中我们可以看到他调用了mio::Poll的poll方法，<strong>并做了事件分发</strong>。</li>
<li>is_idle</li>
<li>background –&gt; Result&lt;Background,Error&gt;<br> 在一个后台线程运行该Reactor,通过返回的Background可以控制Reactor。</li>
<li>impl Park<br> 阻塞当前线程，等待事件发生。</li>
</ol>
<h4 id="Reactor的Park与UnPark"><a href="#Reactor的Park与UnPark" class="headerlink" title="Reactor的Park与UnPark"></a>Reactor的Park与UnPark</h4><p>使用的是mio::Registration中机制</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">park</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; io::<span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>        <span class="hljs-keyword">self</span>.turn(<span class="hljs-literal">None</span>)?;<br>        <span class="hljs-literal">Ok</span>(())<br>    &#125;<br><span class="hljs-comment">//turn调用 的poll方法    </span><br>    <br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">unpark</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> h) = <span class="hljs-keyword">self</span>.inner &#123;<br>            h.wakeup();<br>        &#125;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">wakeup</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(handle) = <span class="hljs-keyword">self</span>.as_priv() &#123;<br>            handle.wakeup();<br>        &#125;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">wakeup</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(inner) = <span class="hljs-keyword">self</span>.inner() &#123;<br>            inner.wakeup.set_readiness(mio::Ready::readable()).unwrap();<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure>

<h4 id="Registration"><a href="#Registration" class="headerlink" title="Registration"></a>Registration</h4><p>一种注册到Reactor中的IO资源，他可以从Reactor接受任务通知。通过register把Evented注册到Reactor中。一个Registeration代表两个stream，一个用于读另一个用于写。</p>
<h5 id="Registration到Reactor的注册过程："><a href="#Registration到Reactor的注册过程：" class="headerlink" title="Registration到Reactor的注册过程："></a>Registration到Reactor的注册过程：</h5><p>1.Registration的<a target="_blank" rel="noopener" href="https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/registration.rs.html#114-117">register</a>方法中执行register2方法<br>2. register2中199行根据Evented和Reactor的handle构造了一个Registration的Inner<br>3. 我们可以下构造过程代码419行，425行调用了Reactor中的方法 <a target="_blank" rel="noopener" href="https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/lib.rs.html#636-663">add_source</a><br>4. add_source方法的657行调用了poll的注册方法</p>
<h5 id="Registration的通知过程"><a href="#Registration的通知过程" class="headerlink" title="Registration的通知过程"></a>Registration的通知过程</h5><ol>
<li>Reactor的<a target="_blank" rel="noopener" href="https://docs.rs/tokio-reactor/0.1.6/src/tokio_reactor/lib.rs.html#324-327">turn</a>方法为入口,他调用了poll方法。</li>
<li>跳到349行poll方法，352行调用了mio::Poll的poll方法，这里会阻塞，返回事件后370判断是内部唤醒事件还是其他事件，其他事件调用dispatch方法。</li>
<li>388行 dispatch方法先获取读锁，用token为key取出相应的task想关记录，匹配事件是否对的上，最后调用task.notify()。</li>
</ol>
<p> Registration中有两个重要的方法，poll_read_ready,poll_write_ready，他们读取Reactor相关的事件。利用这两个函数可以生成两个Future。</p>
<h4 id="PollEvented"><a href="#PollEvented" class="headerlink" title="PollEvented"></a>PollEvented</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PollEvented</span></span>&lt;E: Evented&gt; &#123;<br>    io: <span class="hljs-built_in">Option</span>&lt;E&gt;,<br>    inner: Inner,<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inner</span></span> &#123;<br>    registration: Registration,<br><br>    <span class="hljs-comment">/// Currently visible read readiness</span><br>    read_readiness: AtomicUsize,<br><br>    <span class="hljs-comment">/// Currently visible write readiness</span><br>    write_readiness: AtomicUsize,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从代码可以看出了，他关联了Registration。他进一步包装了Evented和Registration。PollEvented实现了Read AsyncRead和Write AsyncWrite trait,对上层使用更友好了。</p>
<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>时间相关的工具模块，该模块主要包括以下几个功能：</p>
<ol>
<li>Delay,一个future在指定的时间后完成</li>
<li>Interval ,一个Stream,每隔固定的时间产生一个值，值为时间从开始到现在的时间点。</li>
<li>Timeout，包装了一个future或Stream，设置一个上限时间，如果在指定的时间内不能完成则会被cancelled或返回error。</li>
<li><a target="_blank" rel="noopener" href="https://docs.rs/tokio/0.1/tokio/timer/delay_queue/struct.DelayQueue.html">DelayQueue</a>, 一个队列，通过insert,inser_at等函数可以操作这个队列。也可以当做一个Stream，当item的请求过期后就会被返回。</li>
<li><a target="_blank" rel="noopener" href="https://docs.rs/tokio-timer/0.2.7/tokio_timer/timer/struct.Timer.html">Timer</a> Timer跟踪管理时间的状态，当Delay的deadline到时会通知它。<br>创建一个Timer,使用park方法阻塞当前线程，通过handle()获取Timer的Handle, Handle可以用于创建Delay</li>
</ol>
<h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a><a target="_blank" rel="noopener" href="https://docs.rs/tokio/0.1/tokio/runtime/index.html">runtime</a></h2><p>使用tokio时需要Reactor,executor,timer这三者的支持。我们可以手动的把这三者关联起来，但可能比较复杂。如果不想麻烦，我们可以用runtime来把这三者串联并管理起来。</p>
<p>创建runtime时内部做了以下工作：</p>
<ul>
<li>开起一个后台线程执行Reactor,而0.1.11版本以后改为每个工作线程有一个Reactor</li>
<li>开起一个ThreadPoll用于执行futures</li>
<li>每个工作线程运行一个Timer实例</li>
</ul>
<h3 id="runtime的使用"><a href="#runtime的使用" class="headerlink" title="runtime的使用"></a>runtime的使用</h3><h4 id="exapmple"><a href="#exapmple" class="headerlink" title="exapmple"></a>exapmple</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> tokio::net::TcpListener;<br><br><span class="hljs-keyword">let</span> listener = TcpListener::bind(&amp;addr).unwrap();<br><br><span class="hljs-keyword">let</span> server = listener.incoming()<br>    .map_err(|e| <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error = &#123;:?&#125;&quot;</span>, e))<br>    .for_each(|socket| &#123;<br>        tokio::spawn(process(socket))<br>    &#125;);<br><br>tokio::run(server);<br></code></pre></td></tr></table></figure>
<p>可以使用run代替自己创建runtime，run方法会阻塞当前线程直到runtime运行完所有任务。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> tokio::runtime::Runtime;<br><span class="hljs-keyword">use</span> tokio::net::TcpListener;<br><br><span class="hljs-keyword">let</span> listener = TcpListener::bind(&amp;addr).unwrap();<br><span class="hljs-keyword">let</span> server = listener.incoming()<br>    .map_err(|e| <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error = &#123;:?&#125;&quot;</span>, e))<br>    .for_each(|socket| &#123;<br>        tokio::spawn(process(socket))<br>    &#125;);<br><span class="hljs-comment">// Create the runtime</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> rt = Runtime::new().unwrap();<br><br><span class="hljs-comment">// Spawn the server task</span><br>rt.spawn(server);<br><br><span class="hljs-comment">// Wait until the runtime becomes idle and shut it down.</span><br>rt.shutdown_on_idle()<br>    .wait().unwrap();<br></code></pre></td></tr></table></figure>
<p>我们也可以自己创建runtime，并调用spawn方法，他会把future放到配置的threadpoll中去运行并立即返回。shutdown_on_idle方法会阻塞直到所有任务运行完并关闭。</p>
<h4 id="runtime的配置"><a href="#runtime的配置" class="headerlink" title="runtime的配置"></a>runtime的配置</h4><p>ThreadPool使用了work-stealing策略，ThreadPool默认每个cpu core开起一个工作线程</p>
<ol>
<li>通过Runtime的new方法生成默认配置的</li>
<li>通过<a target="_blank" rel="noopener" href="https://docs.rs/tokio/0.1/tokio/runtime/struct.Builder.html">Builder</a>来构造一个满足你想要的配置的Runtime。<br>主要的配置参数有clock,核心线程数，最大阻塞线程数，线程空闲时的存活时间，线程名，线程栈大小等。</li>
</ol>
<h3 id="runtime分析"><a href="#runtime分析" class="headerlink" title="runtime分析"></a>runtime分析</h3><p><a target="_blank" rel="noopener" href="https://docs.rs/tokio/0.1/src/tokio/runtime/mod.rs.html#221-490">source</a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Runtime</span></span> &#123;<br>    inner: <span class="hljs-built_in">Option</span>&lt;Inner&gt;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inner</span></span> &#123;<br>    <span class="hljs-comment">/// A handle to one of the per-worker reactors.</span><br>    reactor: Handle,<br><br>    <span class="hljs-comment">/// Task execution pool.</span><br>    pool: threadpool::ThreadPool,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从代码可以看出Runtime封装了一个线程池和reactor，但这个reactor在0.1.11版本后就没有用了。<br>下面主要分析一下future的执行过程：</p>
<p>1.以Runtime 的<a target="_blank" rel="noopener" href="https://docs.rs/tokio/0.1/src/tokio/runtime/mod.rs.html#342-347">spawn</a>方法为入口,调用了threadpool的sender方法返回一个<a target="_blank" rel="noopener" href="https://tokio-rs.github.io/tokio/tokio_threadpool/struct.Sender.html">Sender</a>，并调用其<a target="_blank" rel="noopener" href="https://tokio-rs.github.io/tokio/src/tokio_threadpool/sender.rs.html#128-133">spawn</a>方法。</p>
<ol start="2">
<li>Sender是一个Executor,spawn中主要做了三件事：<ol>
<li>准备工作，容量及状态检查</li>
<li>new 一个Task</li>
<li>调用pool的<a target="_blank" rel="noopener" href="https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/pool/mod.rs">submit_to_random</a>方法，把这个task随机提交到某个worker中。</li>
</ol>
</li>
</ol>
<p>接下来我们找到工作线程的<a target="_blank" rel="noopener" href="https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/pool/mod.rs">入口</a>，Pool的spawn_thread方法，里面调用 了worker的do_run:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_run</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span> &#123;<br>        <span class="hljs-comment">// Create another worker... It&#x27;s ok, this is just a new type around</span><br>        <span class="hljs-comment">// `Pool` that is expected to stay on the current thread.</span><br>        CURRENT_WORKER.with(|c| &#123;<br>            c.set(<span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _);<br><br>            <span class="hljs-keyword">let</span> inner = <span class="hljs-keyword">self</span>.inner.clone();<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> sender = Sender &#123; inner &#125;;<br><br>            <span class="hljs-comment">// Enter an execution context</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> enter = tokio_executor::enter().unwrap();<br><br>            tokio_executor::with_default(&amp;<span class="hljs-keyword">mut</span> sender, &amp;<span class="hljs-keyword">mut</span> enter, |enter| &#123;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> callback) = <span class="hljs-keyword">self</span>.inner.config.around_worker &#123;<br>                    callback.call(<span class="hljs-keyword">self</span>, enter);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">self</span>.run();<br>                &#125;<br>            &#125;);<br>        &#125;);<br><br>        <span class="hljs-comment">// Can&#x27;t be in blocking mode and finalization mode</span><br>        <span class="hljs-built_in">debug_assert!</span>(!<span class="hljs-keyword">self</span>.is_blocking.get() || !<span class="hljs-keyword">self</span>.should_finalize.get());<br><br>        <span class="hljs-keyword">self</span>.is_blocking.get()<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>来看一下  <strong>tokio_reactor::with_default:</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs rust">thread_local!(<span class="hljs-keyword">static</span> CURRENT_REACTOR: RefCell&lt;<span class="hljs-built_in">Option</span>&lt;HandlePriv&gt;&gt; = RefCell::new(<span class="hljs-literal">None</span>));<br><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with_default</span></span>&lt;F, R&gt;(handle: &amp;Handle, enter: &amp;<span class="hljs-keyword">mut</span> Enter, f: F) -&gt; R<br><span class="hljs-keyword">where</span> F: <span class="hljs-built_in">FnOnce</span>(&amp;<span class="hljs-keyword">mut</span> Enter) -&gt; R<br>&#123;<br>    <span class="hljs-comment">// Ensure that the executor is removed from the thread-local context</span><br>    <span class="hljs-comment">// when leaving the scope. This handles cases that involve panicking.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Reset</span></span>;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Reset &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>            CURRENT_REACTOR.with(|current| &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> current = current.borrow_mut();<br>                *current = <span class="hljs-literal">None</span>;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// This ensures the value for the current reactor gets reset even if there</span><br>    <span class="hljs-comment">// is a panic.</span><br>    <span class="hljs-keyword">let</span> _r = Reset;<br><br>    CURRENT_REACTOR.with(|current| &#123;<br>        &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> current = current.borrow_mut();<br><br>            <span class="hljs-built_in">assert!</span>(current.is_none(), <span class="hljs-string">&quot;default Tokio reactor already set \</span><br><span class="hljs-string">                    for execution context&quot;</span>);<br><br>            <span class="hljs-keyword">let</span> handle = <span class="hljs-keyword">match</span> handle.as_priv() &#123;<br>                <span class="hljs-literal">Some</span>(handle) =&gt; handle,<br>                <span class="hljs-literal">None</span> =&gt; &#123;<br>                    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;`handle` does not reference a reactor&quot;</span>);<br>                &#125;<br>            &#125;;<br><br>            *current = <span class="hljs-literal">Some</span>(handle.clone());<br>        &#125;<br><br>        f(enter)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际是调用了里面的闭包，根据config.around_worker里是否设置了callback来决定是调用callback还是调用了run方法。我们找到around_worker的设置地方，在Runtime的Builder的build方法中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> pool = <span class="hljs-keyword">self</span>.threadpool_builder<br>            .around_worker(<span class="hljs-keyword">move</span> |w, enter| &#123;<br>                <span class="hljs-keyword">let</span> index = w.id().to_usize();<br><br>                tokio_reactor::with_default(&amp;reactor_handles[index], enter, |enter| &#123;<br>                    clock::with_default(&amp;clock, enter, |enter| &#123;<br>                        timer::with_default(&amp;timer_handles[index], enter, |_| &#123;<br>                            w.run();<br>                        &#125;);<br>                    &#125;)<br>                &#125;);<br>            &#125;)<br>        ..............<br>            .build();<br></code></pre></td></tr></table></figure>

<p>来看一下 <strong>clock::with_default 与上面同样的套路：</strong><br> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"> thread_local!(<span class="hljs-keyword">static</span> CLOCK: Cell&lt;<span class="hljs-built_in">Option</span>&lt;*<span class="hljs-keyword">const</span> Clock&gt;&gt; = Cell::new(<span class="hljs-literal">None</span>));<br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with_default</span></span>&lt;F, R&gt;(clock: &amp;Clock, enter: &amp;<span class="hljs-keyword">mut</span> Enter, f: F) -&gt; R<br><span class="hljs-keyword">where</span> F: <span class="hljs-built_in">FnOnce</span>(&amp;<span class="hljs-keyword">mut</span> Enter) -&gt; R<br>&#123;<br>    CLOCK.with(|cell| &#123;<br>        <span class="hljs-built_in">assert!</span>(cell.get().is_none(), <span class="hljs-string">&quot;default clock already set for execution context&quot;</span>);<br><br>        <span class="hljs-comment">// Ensure that the clock is removed from the thread-local context</span><br>        <span class="hljs-comment">// when leaving the scope. This handles cases that involve panicking.</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Reset</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> Cell&lt;<span class="hljs-built_in">Option</span>&lt;*<span class="hljs-keyword">const</span> Clock&gt;&gt;);<br><br>        <span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Reset&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>                <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.set(<span class="hljs-literal">None</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">let</span> _reset = Reset(cell);<br><br>        cell.set(<span class="hljs-literal">Some</span>(clock <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> Clock));<br><br>        f(enter)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>再找到 <strong>timer::with_default也是同样的套路：</strong><br> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"> thread_local!(<span class="hljs-keyword">static</span> CURRENT_TIMER: RefCell&lt;<span class="hljs-built_in">Option</span>&lt;HandlePriv&gt;&gt; = RefCell::new(<span class="hljs-literal">None</span>));<br> <br> <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with_default</span></span>&lt;F, R&gt;(handle: &amp;Handle, enter: &amp;<span class="hljs-keyword">mut</span> Enter, f: F) -&gt; R<br><span class="hljs-keyword">where</span> F: <span class="hljs-built_in">FnOnce</span>(&amp;<span class="hljs-keyword">mut</span> Enter) -&gt; R<br>&#123;<br>    <span class="hljs-comment">// Ensure that the timer is removed from the thread-local context</span><br>    <span class="hljs-comment">// when leaving the scope. This handles cases that involve panicking.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Reset</span></span>;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Reset &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>            CURRENT_TIMER.with(|current| &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> current = current.borrow_mut();<br>                *current = <span class="hljs-literal">None</span>;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// This ensures the value for the current timer gets reset even if there is</span><br>    <span class="hljs-comment">// a panic.</span><br>    <span class="hljs-keyword">let</span> _r = Reset;<br><br>    CURRENT_TIMER.with(|current| &#123;<br>        &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> current = current.borrow_mut();<br><br>            <span class="hljs-built_in">assert!</span>(current.is_none(), <span class="hljs-string">&quot;default Tokio timer already set \</span><br><span class="hljs-string">                    for execution context&quot;</span>);<br><br>            <span class="hljs-keyword">let</span> handle = handle.as_priv()<br>                .unwrap_or_else(|| <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;`handle` does not reference a timer&quot;</span>));<br><br>            *current = <span class="hljs-literal">Some</span>(handle.clone());<br>        &#125;<br><br>        f(enter)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><br> 最后可以看到运行的是Worker的<a target="_blank" rel="noopener" href="https://tokio-rs.github.io/tokio/src/tokio_threadpool/worker/mod.rs.html#219-292">run</a>方法，run方法根据执行的结果进行了状态调整。对看247行try_run_task()方法:<br> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[inline]</span><br>   <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">try_run_task</span></span>(&amp;<span class="hljs-keyword">self</span>, notify: &amp;Arc&lt;Notifier&gt;) -&gt; <span class="hljs-built_in">bool</span> &#123;<br>       <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.try_run_owned_task(notify) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">self</span>.try_steal_task(notify)<br>   &#125;<br></code></pre></td></tr></table></figure></p>
<p> 先进入395行try_run_owned_task方法的实现，调用了458行的run_task方法：<br> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run_task</span></span>(&amp;<span class="hljs-keyword">self</span>, task: Arc&lt;Task&gt;, notify: &amp;Arc&lt;Notifier&gt;) &#123;<br>       <span class="hljs-keyword">use</span> task::Run::*;<br>       <span class="hljs-keyword">let</span> run = <span class="hljs-keyword">self</span>.run_task2(&amp;task, notify);<br>       <span class="hljs-keyword">match</span> run &#123;<br>           Idle =&gt; &#123;&#125;<br>           Schedule =&gt; &#123;<br>               <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.is_blocking.get() &#123;<br>                   <span class="hljs-keyword">self</span>.pool.submit_external(task, &amp;<span class="hljs-keyword">self</span>.pool);<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-keyword">self</span>.entry().push_internal(task);<br>               &#125;<br>           &#125;<br>           Complete =&gt; &#123;<br>               <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> state: pool::State = <span class="hljs-keyword">self</span>.pool.state.load(Acquire).into();<br><br>               <span class="hljs-keyword">loop</span> &#123;<br>                   <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> next = state;<br>                   next.dec_num_futures();<br><br>                   <span class="hljs-keyword">let</span> actual = <span class="hljs-keyword">self</span>.pool.state.compare_and_swap(<br>                       state.into(), next.into(), AcqRel).into();<br><br>                   <span class="hljs-keyword">if</span> actual == state &#123;<br>                       trace!(<span class="hljs-string">&quot;task complete; state=&#123;:?&#125;&quot;</span>, next);<br><br>                       <span class="hljs-keyword">if</span> state.num_futures() == <span class="hljs-number">1</span> &#123;<br>                           <span class="hljs-keyword">if</span> next.is_terminated() &#123;<br>                               <span class="hljs-keyword">self</span>.pool.terminate_sleeping_workers();<br>                           &#125;<br>                       &#125;<br>                       <span class="hljs-keyword">return</span>;<br>                   &#125;<br><br>                   state = actual;<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><br>调用了runtask2方法并对结果做了处理。跟踪到最后一行task.run(),切换到<a target="_blank" rel="noopener" href="https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/task/mod.rs">task.run</a>,我们看到task内有一个类型是UnsafeCell&lt;Option&lt;Spawn<BoxFuture>&gt;&gt;,这个就是future实例了。<br>切换到run方法，看以看到他调用了Spawn的<a target="_blank" rel="noopener" href="https://docs.rs/tokio/0.1/tokio/prelude/task/struct.Spawn.html#method.poll_future_notify">poll_future_notify</a>方法。这个方法在Future中讲过，最终调用了future的poll方法。</p>
<h3 id="ThreadPool中task的notify"><a href="#ThreadPool中task的notify" class="headerlink" title="ThreadPool中task的notify"></a>ThreadPool中task的notify</h3><p>找到<a target="_blank" rel="noopener" href="https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/task/mod.rs">notify</a>方法</p>
<pre><code class="rust"> /// Notify the task
    pub fn notify(me: Arc&lt;Task&gt;, pool: &amp;Arc&lt;Pool&gt;) &#123;
        if me.schedule() &#123;
            let _ = pool.submit(me, pool);
        &#125;
    &#125;
</code></pre>
<p>先判断一下自己的当前状态，然后通过pool把自己提交到线程池中，进入<a target="_blank" rel="noopener" href="https://docs.rs/crate/tokio-threadpool/0.1.8/source/src/pool/mod.rs">submit</a>方法，可以看到熟悉的流程了。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/rust/">rust</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018-11-20-rust-static/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">rust static详解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018-11-17-rust-mio-md/">
                        <span class="hidden-mobile">rust mio</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
    <!-- cnzz Analytics Icon -->
    <span id="cnzz_stat_icon_1279826644" style="display: none"></span>
  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?0451f73cbd5a12ac989afc39ee0d08e7";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  
    <!-- cnzz Analytics -->
    <script defer src="//s4.cnzz.com/z_stat.php?id=1279826644&show=pic"
            type="text/javascript"></script>
  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
